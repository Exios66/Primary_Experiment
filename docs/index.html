<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Advanced Eye Tracking Experiment</title>
    
    <!-- Define loadLocalPsychoJS function to prevent reference errors -->
    <script>
      // This is a placeholder function to prevent "not defined" errors
      function loadLocalPsychoJS() {
        console.log("loadLocalPsychoJS called - using already loaded local implementation");
      }

      // Log when there's an error loading a script
      window.addEventListener('error', function(event) {
        console.log('Error event:', event);
        if (event.target.tagName === 'SCRIPT') {
          console.log('Script error:', event.target.src);
        }
      }, true);
    </script>
    
    <!-- Local PsychoJS implementation -->
    <script src="psychojs-dist/dist/psychojs.js" 
            onerror="console.error('Failed to load psychojs.js from local source');">
    </script>
    <link href="psychojs-dist/dist/psychojs.css" rel="stylesheet">
    <script src="webgazer.js" 
            onerror="console.error('Failed to load webgazer.js from local source');">
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --primary-color: #2563eb;
        --secondary-color: #1e40af;
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --error-color: #ef4444;
        --success-color: #22c55e;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .experiment-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 2rem;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        background: var(--primary-color);
        color: white;
      }

      .btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        height: 8px;
        margin: 1rem 0;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: var(--primary-color);
        transition: width 0.3s ease;
        width: 0%;
      }

      .calibration-point {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .export-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        margin-top: 2rem;
      }

      .export-btn {
        background: transparent;
        border: 2px solid var(--primary-color);
        color: var(--text-color);
      }

      .export-btn:hover {
        background: var(--primary-color);
      }

      .notification {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        padding: 1rem;
        border-radius: 6px;
        background: var(--success-color);
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .notification.show {
        opacity: 1;
      }

      .error {
        background: var(--error-color);
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .controls {
          flex-direction: column;
        }
      }
      
      /* Long duration session styles */
      .session-stats {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        display: none;
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        margin-top: 0.5rem;
      }
      
      .stat-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.75rem;
        border-radius: 4px;
        text-align: center;
      }
      
      .stat-value {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--primary-color);
      }
      
      .stat-label {
        font-size: 0.8rem;
        opacity: 0.7;
      }
      
      .segment-indicator {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 1rem;
      }
      
      .segment-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
      }
      
      .segment-dot.active {
        background: var(--primary-color);
      }
      
      .segment-dot.completed {
        background: var(--success-color);
      }
      
      .long-duration-controls {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        flex-wrap: wrap;
        justify-content: center;
        display: none;
      }
      
      .settings-panel {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 1.5rem;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      }
      
      .settings-group {
        margin-bottom: 1.5rem;
      }
      
      .settings-group h3 {
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 0.5rem;
      }
      
      .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 0.75rem;
      }
      
      .form-row label {
        flex: 1;
      }
      
      .form-row input, .form-row select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.5rem;
        border-radius: 4px;
        color: var(--text-color);
        width: 120px;
      }
      
      .close-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        color: var(--text-color);
        font-size: 1.5rem;
        cursor: pointer;
        opacity: 0.7;
      }
      
      .close-btn:hover {
        opacity: 1;
      }
      
      .pause-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 2rem;
        border-radius: 8px;
        text-align: center;
        z-index: 1100;
        display: none;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }
      
      .pause-indicator h2 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      
      .pulse {
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }
      
      .quality-indicator {
        position: fixed;
        top: 1rem;
        right: 1rem;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--success-color);
        z-index: 1000;
      }
      
      .quality-indicator.medium {
        background: orange;
      }
      
      .quality-indicator.low {
        background: var(--error-color);
      }
      
      /* Timeline visualization for long sessions */
      .timeline {
        height: 2rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        margin-top: 1rem;
        position: relative;
        overflow: hidden;
      }
      
      .timeline-segment {
        position: absolute;
        height: 100%;
        background: var(--primary-color);
        opacity: 0.6;
      }
      
      .timeline-cursor {
        position: absolute;
        width: 2px;
        height: 100%;
        background: white;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Eye Tracking Experiment</h1>
        <p>Advanced gaze tracking using WebGazer.js and PsychoJS</p>
      </div>

      <div class="experiment-status">
        <h2>Status</h2>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <p id="statusText">Initializing experiment...</p>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn" type="button">Start Experiment</button>
        <button class="btn" id="calibrateBtn" type="button" disabled>Calibrate</button>
        <button class="btn" id="abortBtn" type="button" disabled>Stop Experiment</button>
      </div>

      <div class="long-duration-controls" id="longDurationControls">
        <button class="btn" id="startLongSessionBtn" type="button">Start Long Session</button>
        <button class="btn" id="pauseResumeBtn" type="button" disabled>Pause</button>
        <button class="btn" id="settingsBtn" type="button">Settings</button>
        <button class="btn" id="saveSegmentBtn" type="button" disabled>Save Segment</button>
      </div>
      
      <div class="session-stats" id="sessionStats">
        <h3>Long Duration Session Statistics</h3>
        <div class="timeline" id="sessionTimeline">
          <div class="timeline-cursor" id="timelineCursor"></div>
        </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="totalTimeValue">00:00:00</div>
            <div class="stat-label">Total Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="activeTimeValue">00:00:00</div>
            <div class="stat-label">Active Recording</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="pauseTimeValue">00:00:00</div>
            <div class="stat-label">Pause Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="dataPointsValue">0</div>
            <div class="stat-label">Data Points</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="trackingQualityValue">100%</div>
            <div class="stat-label">Tracking Quality</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="segmentCountValue">0</div>
            <div class="stat-label">Segments</div>
          </div>
        </div>
        <div class="segment-indicator" id="segmentIndicator"></div>
      </div>

      <div id="experimentContainer"></div>

      <div class="export-container" id="exportContainer" style="display: none;">
        <button class="btn export-btn" id="exportCSV" type="button">Download CSV Data</button>
        <button class="btn export-btn" id="exportJSON" type="button">Download JSON Data</button>
        <button class="btn export-btn" id="exportAllSegments" type="button">Download All Segments</button>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-btn" id="closeSettingsBtn" type="button">&times;</button>
        <h2>Long Duration Session Settings</h2>
        
        <div class="settings-group">
          <h3>Session Duration</h3>
          <div class="form-row">
            <label for="sessionDurationHours">Session Length (hours)</label>
            <input type="number" id="sessionDurationHours" min="0.1" max="24" step="0.1" value="1">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Segmentation</h3>
          <div class="form-row">
            <label for="segmentDuration">Segment Length (minutes)</label>
            <input type="number" id="segmentDuration" min="1" max="60" step="1" value="10">
          </div>
          <div class="form-row">
            <label for="autoSaveInterval">Auto-save Interval (minutes)</label>
            <input type="number" id="autoSaveInterval" min="1" max="30" step="1" value="5">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Memory Management</h3>
          <div class="form-row">
            <label for="maxGazePoints">Max Points in Memory</label>
            <input type="number" id="maxGazePoints" min="1000" max="100000" step="1000" value="10000">
          </div>
          <div class="form-row">
            <label for="downsamplingFactor">Downsampling Factor</label>
            <select id="downsamplingFactor">
              <option value="1">None (1x)</option>
              <option value="2">Light (2x)</option>
              <option value="5">Medium (5x)</option>
              <option value="10">Heavy (10x)</option>
            </select>
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Auto-pause Detection</h3>
          <div class="form-row">
            <label for="pauseDetectionEnabled">Enable Auto-pause</label>
            <input type="checkbox" id="pauseDetectionEnabled" checked>
          </div>
          <div class="form-row">
            <label for="inactivityThreshold">Inactivity Threshold (seconds)</label>
            <input type="number" id="inactivityThreshold" min="5" max="120" step="5" value="30">
          </div>
        </div>
        
        <button class="btn" id="applySettingsBtn" type="button">Apply Settings</button>
      </div>
      
      <div class="pause-indicator" id="pauseIndicator">
        <h2 class="pulse">Recording Paused</h2>
        <p>Press resume to continue recording</p>
      </div>
      
      <div class="quality-indicator" id="qualityIndicator"></div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
      // Global state
      let psychoJS;
      let experimentWindow;
      let gazeData = [];
      let calibrationData = [];
      let isExperimentRunning = false;
      let currentTrial = 0;
      let heatmapEnabled = false;
      let recordingSession = null;
      let headCalibrationData = null;
      let coordinatePlane = null;
      let heatmapLayer = null;
      let gazeHistory = [];
      let recordingStartTime = null;
      // Long duration session variables
      let isLongDurationSession = false;
      let currentSegment = 0;
      let segmentStartTime = null;
      let isPaused = false;
      let pauseStartTime = null;
      let totalPausedTime = 0;
      let autoSaveInterval = null;
      let lastCleanupTime = null;
      let recordedSegments = [];
      let currentRecordingTime = 0;
      let lastTrackingQuality = 1.0;
      let inactivityTimer = null;
      // Advanced eye tracking state
      let eyeMovementData = {
        fixations: [],
        saccades: [],
        smoothPursuits: [],
        blinks: []
      };
      let gazeMetrics = {};
      let realTimeAnalysisEnabled = true;
      let analysisUpdateInterval = null;
      let lastAnalysisTime = 0;
      let eyeMovementVisualization = {
        showFixations: true,
        showSaccades: false,
        showPursuits: false,
        fixationRadiusScale: 0.5   // Scale factor for fixation circles
      };
      let sessionStats = {
        totalDuration: 0,
        activeDuration: 0,
        pauseDuration: 0,
        dataPoints: 0,
        avgTrackingQuality: 1.0,
        segmentCount: 0,
        // New advanced metrics
        fixationCount: 0,
        avgFixationDuration: 0,
        saccadeCount: 0,
        blinkRate: 0,
        pursuitCount: 0
      };

      // Configuration
      const config = {
        fullscreen: true,
        backgroundColor: '#0f172a',
        frameRate: 60,
        calibrationPoints: 9,
        trialCount: 5,
        sampleRate: 30,
        heatmapResolution: 50,
        heatmapOpacity: 0.6,
        heatmapRadius: 50,
        heatmapColorScale: ['blue', 'green', 'yellow', 'red'],
        coordinatePlaneColor: 'rgba(255, 255, 255, 0.2)',
        coordinatePlaneSpacing: 50,
        recordingDuration: 60, // seconds
        headCalibrationSamples: 30,
        // Long duration session options
        longDurationEnabled: false,
        longDurationHours: 1, // Default 1 hour for long sessions
        segmentDuration: 10 * 60, // 10 minutes per segment
        autoSaveInterval: 5 * 60, // Auto-save every 5 minutes
        memoryManagement: {
          maxGazeHistoryPoints: 10000, // Maximum points to keep in memory
          cleanupInterval: 60, // Cleanup every 1 minute
          sampleDownsamplingFactor: 1 // No downsampling by default
        },
        pauseDetection: {
          enabled: true,
          inactivityThreshold: 30, // Seconds of inactivity before pausing
          lowQualityThreshold: 0.4 // Threshold for low quality tracking
        },
        visualization: {
          timeWindow: 60, // Show last 60 seconds in visualizations by default
          heatmapTemporalDecay: 0.9 // Decay factor for older points
        },
        // Advanced eye tracking configuration
        eyeTracking: {
          realTimeAnalysisEnabled: true,
          analysisInterval: 500, // ms between analysis updates
          fixationSettings: {
            minDuration: 100, // ms
            dispersionThreshold: 35, // pixels
            maximumGap: 75 // ms, maximum time between samples to be considered part of the same fixation
          },
          saccadeSettings: {
            velocityThreshold: 300, // pixels/second
            accelerationThreshold: 9500 // pixels/second²
          },
          blinkSettings: {
            maxGapDuration: 400 // ms
          },
          pursuitSettings: {
            velocityRange: [30, 150], // pixels/second
            directionChangeMax: 45 // degrees
          },
          visualization: {
            showFixations: true,
            showSaccades: false,
            showPursuits: false,
            fixationRadiusScale: 0.5
          }
        }
      };

      // UI Elements
      const ui = {
        startBtn: document.getElementById('startBtn'),
        calibrateBtn: document.getElementById('calibrateBtn'),
        abortBtn: document.getElementById('abortBtn'),
        progressBar: document.getElementById('progressBar'),
        statusText: document.getElementById('statusText'),
        notification: document.getElementById('notification'),
        exportContainer: document.getElementById('exportContainer')
      };

      // Initialize WebGazer
      async function initializeWebGazer() {
        try {
          ui.statusText.textContent = 'Initializing WebGazer...';
          updateProgress(10);
          
          await webgazer.setGazeListener((data, timestamp) => {
            if (data && isExperimentRunning) {
              gazeData.push({
                timestamp,
                x: data.x,
                y: data.y,
                trial: currentTrial
              });
            }
          }).begin();
          
          updateProgress(50);
          ui.statusText.textContent = 'WebGazer initialized successfully';
      
          // Configure WebGazer
          webgazer.showVideo(false)
                   .showFaceOverlay(false)
                   .showFaceFeedbackBox(false)
                   .showPredictionPoints(false);

          updateProgress(75);
          return true;
        } catch (error) {
          console.error("WebGazer initialization failed:", error);
          showNotification('Failed to initialize WebGazer: ' + error.message, true);
          return false;
        }
      }

      // Initialize PsychoJS
      function initializePsychoJS() {
        try {
          // Check if PsychoJS is defined
          if (typeof PsychoJS === 'undefined') {
            console.error("PsychoJS is not defined. Make sure the library is loaded correctly.");
            showNotification("PsychoJS library failed to load", true);
            return false;
          }
          
          psychoJS = new PsychoJS({
            debug: true
          });

          experimentWindow = new psychoJS.visual.Window({
            size: [window.innerWidth, window.innerHeight],
            fullscr: config.fullscreen,
            color: new psychoJS.Color(config.backgroundColor),
            units: 'norm'
          });
          
          updateProgress(25); // Update progress to indicate successful initialization
          return true;
        } catch (error) {
          console.error("Error initializing PsychoJS:", error);
          showNotification("Failed to initialize PsychoJS: " + error.message, true);
          return false;
        }
      }

      // Calibration procedure
      async function runCalibration() {
        const points = [
          [-0.8, 0.8], [0, 0.8], [0.8, 0.8],
          [-0.8, 0], [0, 0], [0.8, 0],
          [-0.8, -0.8], [0, -0.8], [0.8, -0.8]
        ];

        calibrationData = [];
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          
          // Create calibration point
          const dot = new psychoJS.visual.Circle({
            win: experimentWindow,
            radius: 0.02,
            pos: point,
            fillColor: new psychoJS.Color('white'),
            lineWidth: 0
          });

          // Show point
          dot.draw();
          experimentWindow.flip();

          // Wait for fixation
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Collect samples
          const samples = [];
          for (let j = 0; j < 10; j++) {
            const prediction = await webgazer.getCurrentPrediction();
            if (prediction) {
              samples.push({
                x: prediction.x,
                y: prediction.y
              });
            }
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          // Calculate average
          if (samples.length > 0) {
            const avgX = samples.reduce((sum, s) => sum + s.x, 0) / samples.length;
            const avgY = samples.reduce((sum, s) => sum + s.y, 0) / samples.length;
            
            calibrationData.push({
              target: point,
              measured: [avgX, avgY]
            });
          }

          // Update progress
          updateProgress((i + 1) / points.length * 100);
        }

        // Assess calibration quality
        const calibrationQuality = assessCalibrationQuality(calibrationData);
        if (calibrationQuality.score < 0.6) {
          showNotification(`Calibration quality is low (${Math.round(calibrationQuality.score * 100)}%). Consider recalibrating.`, true);
        } else {
          showNotification(`Calibration quality: ${Math.round(calibrationQuality.score * 100)}%`);
        }

        return calibrationData.length === points.length;
      }

      // Advanced calibration quality assessment
      function assessCalibrationQuality(calibrationData) {
        if (!calibrationData || calibrationData.length === 0) {
          return { score: 0, details: "No calibration data available" };
        }
        
        // Convert normalized coordinates to pixel coordinates for easier interpretation
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        // Calculate error metrics for each calibration point
        const pointErrors = calibrationData.map(point => {
          // Convert normalized target coordinates to pixels
          const targetX = ((point.target[0] + 1) / 2) * screenWidth;
          const targetY = ((point.target[1] + 1) / 2) * screenHeight;
          
          // Measured coordinates are already in pixels
          const measuredX = point.measured[0];
          const measuredY = point.measured[1];
          
          // Calculate Euclidean distance error
          const error = Math.sqrt(
            Math.pow(targetX - measuredX, 2) + 
            Math.pow(targetY - measuredY, 2)
          );
          
          return {
            target: [targetX, targetY],
            measured: [measuredX, measuredY],
            error: error
          };
        });
        
        // Calculate overall metrics
        const totalError = pointErrors.reduce((sum, p) => sum + p.error, 0);
        const avgError = totalError / pointErrors.length;
        const maxError = Math.max(...pointErrors.map(p => p.error));
        
        // Calculate standard deviation of errors
        const errorVariance = pointErrors.reduce((sum, p) => sum + Math.pow(p.error - avgError, 2), 0) / pointErrors.length;
        const errorStdDev = Math.sqrt(errorVariance);
        
        // Calculate normalized quality score (0-1, higher is better)
        // We'll use a sigmoid function to map average error to a quality score
        // Typical screen diagonal is used as a reference for normalizing error
        const screenDiagonal = Math.sqrt(Math.pow(screenWidth, 2) + Math.pow(screenHeight, 2));
        const normalizedAvgError = avgError / (screenDiagonal * 0.1); // 10% of screen diagonal as reference
        const qualityScore = 1 / (1 + Math.exp((normalizedAvgError - 1) * 5));
        
        return {
          score: qualityScore,
          avgError: avgError,
          maxError: maxError,
          stdDev: errorStdDev,
          pointErrors: pointErrors,
          uniformity: 1 - (errorStdDev / avgError) // Higher value means more uniform errors
        };
      }

      // Advanced gaze data filtering
      function filterGazeData(rawData, options = {}) {
        if (!rawData || rawData.length === 0) return [];
        
        const defaults = {
          outlierThreshold: 2.5, // Standard deviations for outlier detection
          velocityThreshold: 1000, // pixels/second for saccade detection
          medianFilterSize: 3, // Window size for median filter
          smoothingFactor: 0.2, // For exponential smoothing (0-1)
          jitterRadius: 10, // pixels, for jitter detection
          minSampleDistance: 5, // Min distance between consecutive samples to keep
          timeWindow: 100 // ms, time window for velocity calculation
        };
        
        const settings = { ...defaults, ...options };
        let filteredData = [...rawData];
        
        // Step 1: Remove missing or invalid values
        filteredData = filteredData.filter(d => 
          d && d.x !== undefined && !isNaN(d.x) && 
          d.y !== undefined && !isNaN(d.y) && 
          d.timestamp !== undefined
        );
        
        if (filteredData.length === 0) return [];
        
        // Step 2: Outlier removal using Median Absolute Deviation (more robust than std dev)
        if (filteredData.length > 5) {
          // Calculate median positions
          const xValues = filteredData.map(d => d.x);
          const yValues = filteredData.map(d => d.y);
          
          const medianX = calculateMedian(xValues);
          const medianY = calculateMedian(yValues);
          
          // Calculate deviations
          const xDeviations = xValues.map(x => Math.abs(x - medianX));
          const yDeviations = yValues.map(y => Math.abs(y - medianY));
          
          // Calculate MAD
          const madX = calculateMedian(xDeviations);
          const madY = calculateMedian(yDeviations);
          
          // Filter using MAD outlier detection (more robust than z-score)
          filteredData = filteredData.filter((d, i) => {
            const xDevScore = xDeviations[i] / (madX || 1); // Avoid division by zero
            const yDevScore = yDeviations[i] / (madY || 1);
            return xDevScore < settings.outlierThreshold && yDevScore < settings.outlierThreshold;
          });
        }
        
        // Step 3: Velocity-based filtering (for saccade detection)
        if (filteredData.length > 2) {
          const velocityFiltered = [];
          
          for (let i = 1; i < filteredData.length; i++) {
            const current = filteredData[i];
            const prev = filteredData[i-1];
            
            // Calculate time difference in seconds
            const dt = (current.timestamp - prev.timestamp) / 1000;
            
            // Skip if time difference is too small or zero to avoid division by zero
            if (dt <= 0.001) {
              velocityFiltered.push(current);
              continue;
            }
            
            // Calculate velocity in pixels per second
            const dx = current.x - prev.x;
            const dy = current.y - prev.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            const velocity = distance / dt;
            
            // Add velocity information to the data point
            current.velocity = velocity;
            
            // Keep points with velocity below threshold (not a saccade)
            if (velocity < settings.velocityThreshold) {
              velocityFiltered.push(current);
            }
          }
          
          filteredData = velocityFiltered;
        }
        
        // Step 4: Apply exponential smoothing
        if (filteredData.length > 1) {
          const smoothed = [filteredData[0]]; // Keep first point unchanged
          
          for (let i = 1; i < filteredData.length; i++) {
            const current = { ...filteredData[i] };
            const prev = smoothed[i-1];
            
            // Apply exponential smoothing formula: y_smooth = α * y_current + (1-α) * y_prev
            current.x = settings.smoothingFactor * current.x + (1 - settings.smoothingFactor) * prev.x;
            current.y = settings.smoothingFactor * current.y + (1 - settings.smoothingFactor) * prev.y;
            
            smoothed.push(current);
          }
          
          filteredData = smoothed;
        }
        
        // Step 5: Add derived metrics for analysis
        for (let i = 1; i < filteredData.length; i++) {
          const current = filteredData[i];
          const prev = filteredData[i-1];
          
          // Calculate gaze displacement
          const dx = current.x - prev.x;
          const dy = current.y - prev.y;
          const displacement = Math.sqrt(dx*dx + dy*dy);
          
          // Time difference in ms
          const timeDiff = current.timestamp - prev.timestamp;
          
          // Add derived metrics
          current.displacement = displacement;
          current.timeDelta = timeDiff;
          current.velocity = current.velocity || (timeDiff > 0 ? (displacement / timeDiff) * 1000 : 0);
        }
        
        return filteredData;
      }

      // Helper function to calculate median
      function calculateMedian(values) {
        if (!values || values.length === 0) return 0;
        
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        
        if (sorted.length % 2 === 0) {
          return (sorted[mid - 1] + sorted[mid]) / 2;
        } else {
          return sorted[mid];
        }
      }

      // Advanced eye movement detection and classification
      function detectEyeMovements(gazeData, options = {}) {
        if (!gazeData || gazeData.length < 3) {
          return { fixations: [], saccades: [], smoothPursuits: [], blinks: [] };
        }
        
        // Default parameters for eye movement detection
        const defaults = {
          fixationMinDuration: 100, // ms
          fixationDispersionThreshold: 30, // pixels
          saccadeVelocityThreshold: 300, // pixels/second
          blinkDetectionEnabled: true,
          pursuitDetectionEnabled: true,
          pursuitVelocityRange: [30, 150], // pixels/second
          pursuitDirectionChangeMax: 45, // degrees
          blinkMaxGapDuration: 400 // ms
        };
        
        const settings = { ...defaults, ...options };
        
        // Filter and prepare the data
        const data = filterGazeData(gazeData, {
          outlierThreshold: 3.0,
          smoothingFactor: 0.1
        });
        
        if (data.length < 3) {
          return { fixations: [], saccades: [], smoothPursuits: [], blinks: [] };
        }
        
        // 1. Identify blinks (data gaps)
        const blinks = [];
        const nonBlinkData = [];
        let lastTimestamp = data[0].timestamp;
        
        // First detect blinks (missing data or large gaps)
        if (settings.blinkDetectionEnabled) {
          for (let i = 0; i < data.length; i++) {
            const point = data[i];
            
            // Check for missing data points indicating potential blinks
            if (i > 0) {
              const gap = point.timestamp - lastTimestamp;
              
              // Large gap could indicate a blink
              if (gap > settings.blinkMaxGapDuration) {
                blinks.push({
                  startTime: lastTimestamp,
                  endTime: point.timestamp,
                  duration: gap
                });
                
                // Skip this point from further analysis
                lastTimestamp = point.timestamp;
                continue;
              }
            }
            
            lastTimestamp = point.timestamp;
            nonBlinkData.push(point);
          }
        } else {
          // If blink detection disabled, use all data
          nonBlinkData.push(...data);
        }
        
        // 2. Algorithm: Velocity-Based Detection with Adaptive Thresholds
        const events = [];
        const velocities = nonBlinkData.map(d => d.velocity || 0);
        
        // Calculate stats for adaptive thresholding
        const medianVelocity = calculateMedian(velocities);
        const highVelocities = velocities.filter(v => v > medianVelocity);
        const lowVelocities = velocities.filter(v => v <= medianVelocity);
        
        // Adaptive thresholds based on data
        const adaptiveSaccadeThreshold = settings.saccadeVelocityThreshold;
        const adaptiveFixationThreshold = Math.min(
          settings.fixationDispersionThreshold,
          calculateMedian(lowVelocities) * 3
        );
        
        // Analyze data points
        let currentEvent = {
          type: 'unknown',
          startIndex: 0,
          points: [nonBlinkData[0]],
          velocities: [nonBlinkData[0].velocity || 0]
        };
        
        for (let i = 1; i < nonBlinkData.length; i++) {
          const point = nonBlinkData[i];
          const velocity = point.velocity || 0;
          
          // Decision logic for event classification
          if (velocity > adaptiveSaccadeThreshold) {
            // High velocity indicates a saccade
            if (currentEvent.type !== 'saccade') {
              // End the previous event and start a new saccade
              if (currentEvent.points.length > 0) {
                finishEvent(currentEvent);
                events.push(currentEvent);
              }
              
              currentEvent = {
                type: 'saccade',
                startIndex: i,
                points: [point],
                velocities: [velocity]
              };
            } else {
              // Continue the current saccade
              currentEvent.points.push(point);
              currentEvent.velocities.push(velocity);
            }
          } else if (velocity < adaptiveFixationThreshold) {
            // Low velocity indicates a fixation
            
            // Check spatial dispersion for fixation
            let isWithinFixationThreshold = true;
            if (currentEvent.type === 'fixation' && currentEvent.points.length > 0) {
              const centroidX = currentEvent.centroidX;
              const centroidY = currentEvent.centroidY;
              const distance = Math.sqrt(
                Math.pow(point.x - centroidX, 2) +
                Math.pow(point.y - centroidY, 2)
              );
              
              isWithinFixationThreshold = distance < settings.fixationDispersionThreshold;
            }
            
            if (currentEvent.type !== 'fixation' || !isWithinFixationThreshold) {
              // End the previous event and start a new fixation
              if (currentEvent.points.length > 0) {
                finishEvent(currentEvent);
                events.push(currentEvent);
              }
              
              // Initialize centroid with first point
              currentEvent = {
                type: 'fixation',
                startIndex: i,
                points: [point],
                velocities: [velocity],
                centroidX: point.x,
                centroidY: point.y
              };
            } else {
              // Update the current fixation
              currentEvent.points.push(point);
              currentEvent.velocities.push(velocity);
              
              // Recalculate centroid with new point
              const n = currentEvent.points.length;
              currentEvent.centroidX = (currentEvent.centroidX * (n-1) + point.x) / n;
              currentEvent.centroidY = (currentEvent.centroidY * (n-1) + point.y) / n;
            }
          } else {
            // Medium velocity could be smooth pursuit
            if (settings.pursuitDetectionEnabled) {
              // Check if velocity is in pursuit range
              const isPursuit = velocity >= settings.pursuitVelocityRange[0] && 
                              velocity <= settings.pursuitVelocityRange[1];
              
              // Check direction consistency for pursuit
              let isDirectionConsistent = true;
              if (currentEvent.type === 'smooth_pursuit' && currentEvent.points.length > 1) {
                const prevPoint = currentEvent.points[currentEvent.points.length - 1];
                const prevPrevPoint = currentEvent.points[currentEvent.points.length - 2];
                
                // Calculate direction vectors
                const dir1 = {
                  x: prevPoint.x - prevPrevPoint.x,
                  y: prevPoint.y - prevPrevPoint.y
                };
                
                const dir2 = {
                  x: point.x - prevPoint.x,
                  y: point.y - prevPoint.y
                };
                
                // Calculate angle between vectors
                const dot = dir1.x * dir2.x + dir1.y * dir2.y;
                const mag1 = Math.sqrt(dir1.x * dir1.x + dir1.y * dir1.y);
                const mag2 = Math.sqrt(dir2.x * dir2.x + dir2.y * dir2.y);
                
                if (mag1 > 0 && mag2 > 0) {
                  const cosAngle = dot / (mag1 * mag2);
                  const angleRad = Math.acos(Math.min(Math.max(cosAngle, -1), 1));
                  const angleDeg = angleRad * (180 / Math.PI);
                  
                  isDirectionConsistent = angleDeg < settings.pursuitDirectionChangeMax;
                }
              }
              
              if (isPursuit && (currentEvent.type === 'smooth_pursuit' && isDirectionConsistent)) {
                // Continue the current smooth pursuit
                currentEvent.points.push(point);
                currentEvent.velocities.push(velocity);
              } else if (isPursuit) {
                // End the previous event and start a new smooth pursuit
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                currentEvent = {
                  type: 'smooth_pursuit',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity]
                };
              } else {
                // Not a pursuit, treat as saccade or fixation based on velocity
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                // Default to fixation if in doubt
                currentEvent = {
                  type: 'fixation',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity],
                  centroidX: point.x,
                  centroidY: point.y
                };
              }
            } else {
              // If pursuit detection disabled, classify as fixation
              if (currentEvent.type !== 'fixation') {
                // End the previous event and start a new fixation
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                currentEvent = {
                  type: 'fixation',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity],
                  centroidX: point.x,
                  centroidY: point.y
                };
              } else {
                // Update the current fixation
                currentEvent.points.push(point);
                currentEvent.velocities.push(velocity);
                
                // Recalculate centroid
                const n = currentEvent.points.length;
                currentEvent.centroidX = (currentEvent.centroidX * (n-1) + point.x) / n;
                currentEvent.centroidY = (currentEvent.centroidY * (n-1) + point.y) / n;
              }
            }
          }
        }
        
        // Add the final event
        if (currentEvent.points.length > 0) {
          finishEvent(currentEvent);
          events.push(currentEvent);
        }
        
        // Extract events by type
        const fixations = events
          .filter(e => e.type === 'fixation' && e.duration >= settings.fixationMinDuration)
          .map(processFurtherFixation);
          
        const saccades = events
          .filter(e => e.type === 'saccade')
          .map(processFurtherSaccade);
          
        const smoothPursuits = events
          .filter(e => e.type === 'smooth_pursuit')
          .map(processFurtherPursuit);
        
        return {
          fixations,
          saccades,
          smoothPursuits,
          blinks
        };
        
        // Helper to finish processing an event
        function finishEvent(event) {
          if (event.points.length < 2) return;
          
          const startTime = event.points[0].timestamp;
          const endTime = event.points[event.points.length - 1].timestamp;
          
          event.startTime = startTime;
          event.endTime = endTime;
          event.duration = endTime - startTime;
          
          // Calculate average velocity
          event.avgVelocity = event.velocities.reduce((sum, v) => sum + v, 0) / event.velocities.length;
          
          // For fixations, refine centroid and calculate dispersion
          if (event.type === 'fixation') {
            // Calculate all x and y coordinates
            const xValues = event.points.map(p => p.x);
            const yValues = event.points.map(p => p.y);
            
            // Calculate dispersion as max distance from center
            const dispX = Math.max(...xValues) - Math.min(...xValues);
            const dispY = Math.max(...yValues) - Math.min(...yValues);
            event.dispersion = Math.max(dispX, dispY);
            
            // Store the positions for this fixation
            event.x = event.centroidX;
            event.y = event.centroidY;
          }
          
          // For saccades, calculate amplitude and direction
          if (event.type === 'saccade') {
            const startX = event.points[0].x;
            const startY = event.points[0].y;
            const endX = event.points[event.points.length - 1].x;
            const endY = event.points[event.points.length - 1].y;
            
            event.startX = startX;
            event.startY = startY;
            event.endX = endX;
            event.endY = endY;
            
            // Calculate amplitude (distance)
            event.amplitude = Math.sqrt(
              Math.pow(endX - startX, 2) + 
              Math.pow(endY - startY, 2)
            );
            
            // Calculate direction in degrees (0=right, 90=up, 180=left, 270=down)
            event.direction = (Math.atan2(endY - startY, endX - startX) * 180 / Math.PI + 360) % 360;
            
            // Peak velocity
            event.peakVelocity = Math.max(...event.velocities);
          }
          
          // For smooth pursuits, calculate path and direction
          if (event.type === 'smooth_pursuit') {
            const startX = event.points[0].x;
            const startY = event.points[0].y;
            const endX = event.points[event.points.length - 1].x;
            const endY = event.points[event.points.length - 1].y;
            
            event.startX = startX;
            event.startY = startY;
            event.endX = endX;
            event.endY = endY;
            
            // Calculate path length (sum of all point-to-point distances)
            let pathLength = 0;
            for (let i = 1; i < event.points.length; i++) {
              const dx = event.points[i].x - event.points[i-1].x;
              const dy = event.points[i].y - event.points[i-1].y;
              pathLength += Math.sqrt(dx*dx + dy*dy);
            }
            event.pathLength = pathLength;
            
            // Calculate straightness (direct distance / path length)
            const directDistance = Math.sqrt(
              Math.pow(endX - startX, 2) + 
              Math.pow(endY - startY, 2)
            );
            event.straightness = directDistance / (pathLength || 1); // Avoid division by zero
            
            // Average direction
            event.direction = (Math.atan2(endY - startY, endX - startX) * 180 / Math.PI + 360) % 360;
          }
        }
        
        // Further processing for fixations
        function processFurtherFixation(fixation) {
          // Add additional metrics for fixations
          
          // Calculate temporal precision (stability over time)
          const timePoints = fixation.points.map(p => p.timestamp);
          const timeDiffs = [];
          for (let i = 1; i < timePoints.length; i++) {
            timeDiffs.push(timePoints[i] - timePoints[i-1]);
          }
          
          fixation.temporalPrecision = timeDiffs.length > 0 ? 
            calculateMedian(timeDiffs) : 0;
          
          return fixation;
        }
        
        // Further processing for saccades
        function processFurtherSaccade(saccade) {
          // Additional metrics for saccades
          
          // Calculate main sequence relationship (peak velocity / amplitude)
          saccade.mainSequence = saccade.peakVelocity / (saccade.amplitude || 1);
          
          // Calculate acceleration phase
          const halfIdx = Math.floor(saccade.velocities.length / 2);
          saccade.accelerationPhase = saccade.velocities.slice(0, halfIdx);
          saccade.decelerationPhase = saccade.velocities.slice(halfIdx);
          
          return saccade;
        }
        
        // Further processing for smooth pursuits
        function processFurtherPursuit(pursuit) {
          // Additional metrics for smooth pursuits
          
          // Calculate velocity stability (standard deviation of velocity)
          const velocityMean = pursuit.avgVelocity;
          const velocityVariance = pursuit.velocities.reduce(
            (sum, v) => sum + Math.pow(v - velocityMean, 2), 0
          ) / pursuit.velocities.length;
          
          pursuit.velocityStability = Math.sqrt(velocityVariance) / velocityMean;
          
          return pursuit;
        }
      }

      // Enhanced gaze analysis functions
      function analyzeGaze(gazeData, options = {}) {
        if (!gazeData || gazeData.length < 3) {
          return { success: false, message: "Insufficient gaze data for analysis" };
        }
        
        // Detect eye movements
        const eyeMovements = detectEyeMovements(gazeData, options);
        
        // Extract fixations and saccades
        const { fixations, saccades, smoothPursuits, blinks } = eyeMovements;
        
        // Screen dimensions
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        // Aggregated metrics
        const metrics = {
          // Basic count stats
          totalSamples: gazeData.length,
          trackingRate: calculateTrackingRate(gazeData),
          
          // Fixation metrics
          fixationCount: fixations.length,
          averageFixationDuration: fixations.length > 0 ? 
            fixations.reduce((sum, f) => sum + f.duration, 0) / fixations.length : 0,
          totalFixationTime: fixations.reduce((sum, f) => sum + f.duration, 0),
          
          // Saccade metrics
          saccadeCount: saccades.length,
          averageSaccadeAmplitude: saccades.length > 0 ?
            saccades.reduce((sum, s) => sum + s.amplitude, 0) / saccades.length : 0,
          averageSaccadeVelocity: saccades.length > 0 ?
            saccades.reduce((sum, s) => sum + s.avgVelocity, 0) / saccades.length : 0,
          
          // Pursuit metrics
          pursuitCount: smoothPursuits.length,
          averagePursuitDuration: smoothPursuits.length > 0 ?
            smoothPursuits.reduce((sum, p) => sum + p.duration, 0) / smoothPursuits.length : 0,
          
          // Blink metrics
          blinkCount: blinks.length,
          blinkRate: blinks.length / (gazeData[gazeData.length - 1].timestamp - gazeData[0].timestamp) * 60000, // blinks per minute
          
          // Coverage metrics
          spatialDensity: calculateSpatialDensity(fixations, screenWidth, screenHeight),
          
          // Define regions of interest (example: divide screen into 9 regions)
          regionAnalysis: analyzeRegionsOfInterest(fixations, {
            regions: defineRegions(screenWidth, screenHeight)
          }),
          
          // Scanpath metrics
          scanpathLength: calculateScanpathLength(fixations),
          scanpathArea: calculateConvexHullArea(fixations),
          
          // Transitional metrics
          transitionMatrix: calculateTransitionMatrix(fixations, {
            regions: defineRegions(screenWidth, screenHeight)
          })
        };
        
        return {
          success: true,
          metrics,
          eyeMovements,
          regions: defineRegions(screenWidth, screenHeight)
        };
        
        // Helper function to calculate tracking rate
        function calculateTrackingRate(data) {
          if (data.length < 2) return 0;
          
          const duration = data[data.length - 1].timestamp - data[0].timestamp;
          return (data.length / duration) * 1000; // samples per second
        }
        
        // Helper function to define regions of interest
        function defineRegions(width, height, rows = 3, cols = 3) {
          const regions = [];
          const cellWidth = width / cols;
          const cellHeight = height / rows;
          
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              regions.push({
                id: row * cols + col,
                name: `R${row * cols + col + 1}`,
                x: col * cellWidth,
                y: row * cellHeight,
                width: cellWidth,
                height: cellHeight
              });
            }
          }
          
          return regions;
        }
        
        // Helper function to analyze fixations in regions of interest
        function analyzeRegionsOfInterest(fixations, { regions }) {
          // Count fixations in each region
          const regionCounts = Array(regions.length).fill(0);
          const regionDurations = Array(regions.length).fill(0);
          
          fixations.forEach(fixation => {
            const regionIndex = getRegionIndex(fixation.x, fixation.y, regions);
            if (regionIndex >= 0) {
              regionCounts[regionIndex]++;
              regionDurations[regionIndex] += fixation.duration;
            }
          });
          
          // Calculate aggregated metrics for each region
          return regions.map((region, index) => ({
            regionId: region.id,
            regionName: region.name,
            fixationCount: regionCounts[index],
            fixationPercentage: fixations.length > 0 ? 
              (regionCounts[index] / fixations.length) * 100 : 0,
            totalFixationTime: regionDurations[index],
            fixationTimePercentage: regionDurations.reduce((sum, d) => sum + d, 0) > 0 ?
              (regionDurations[index] / regionDurations.reduce((sum, d) => sum + d, 0)) * 100 : 0
          }));
        }
        
        // Helper function to get region index for a point
        function getRegionIndex(x, y, regions) {
          for (let i = 0; i < regions.length; i++) {
            const region = regions[i];
            if (x >= region.x && x < region.x + region.width &&
                y >= region.y && y < region.y + region.height) {
              return i;
            }
          }
          return -1; // Point is outside all regions
        }
        
        // Helper function to calculate spatial density
        function calculateSpatialDensity(fixations, screenWidth, screenHeight) {
          if (fixations.length === 0) return 0;
          
          // Create a grid over the screen
          const gridSize = 10; // 10x10 grid
          const cellWidth = screenWidth / gridSize;
          const cellHeight = screenHeight / gridSize;
          
          // Count occupied cells
          const occupiedCells = new Set();
          
          fixations.forEach(fixation => {
            const gridX = Math.floor(fixation.x / cellWidth);
            const gridY = Math.floor(fixation.y / cellHeight);
            occupiedCells.add(`${gridX},${gridY}`);
          });
          
          // Return percentage of grid cells that received at least one fixation
          return (occupiedCells.size / (gridSize * gridSize)) * 100;
        }
        
        // Helper function to calculate scanpath length
        function calculateScanpathLength(fixations) {
          if (fixations.length < 2) return 0;
          
          let length = 0;
          for (let i = 1; i < fixations.length; i++) {
            const dx = fixations[i].x - fixations[i-1].x;
            const dy = fixations[i].y - fixations[i-1].y;
            length += Math.sqrt(dx*dx + dy*dy);
          }
          
          return length;
        }
        
        // Helper function to calculate convex hull area of fixations
        function calculateConvexHullArea(fixations) {
          if (fixations.length < 3) return 0;
          
          // Extract points
          const points = fixations.map(f => ({ x: f.x, y: f.y }));
          
          // Compute convex hull (Gift wrapping algorithm)
          const hull = computeConvexHull(points);
          
          // Calculate area of polygon
          return calculatePolygonArea(hull);
          
          // Gift wrapping algorithm for convex hull
          function computeConvexHull(points) {
            if (points.length < 3) return points;
            
            // Find leftmost point
            let leftmost = 0;
            for (let i = 1; i < points.length; i++) {
              if (points[i].x < points[leftmost].x) {
                leftmost = i;
              }
            }
            
            const hull = [];
            let p = leftmost;
            
            do {
              hull.push(points[p]);
              
              let q = (p + 1) % points.length;
              for (let i = 0; i < points.length; i++) {
                if (orientation(points[p], points[i], points[q]) === 2) {
                  q = i;
                }
              }
              
              p = q;
            } while (p !== leftmost);
            
            return hull;
          }
          
          // Calculate orientation of triplet (p, q, r)
          function orientation(p, q, r) {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0; // collinear
            return (val > 0) ? 1 : 2; // clockwise or counterclockwise
          }
          
          // Calculate area of polygon using Shoelace formula
          function calculatePolygonArea(vertices) {
            let area = 0;
            const n = vertices.length;
            
            for (let i = 0; i < n; i++) {
              const j = (i + 1) % n;
              area += vertices[i].x * vertices[j].y;
              area -= vertices[j].x * vertices[i].y;
            }
            
            return Math.abs(area) / 2;
          }
        }
        
        // Helper function to calculate transition matrix between regions
        function calculateTransitionMatrix(fixations, { regions }) {
          if (fixations.length < 2) return [];
          
          // Initialize transition matrix with zeros
          const n = regions.length;
          const matrix = Array(n).fill().map(() => Array(n).fill(0));
          
          // Count transitions between regions
          for (let i = 1; i < fixations.length; i++) {
            const fromRegion = getRegionIndex(fixations[i-1].x, fixations[i-1].y, regions);
            const toRegion = getRegionIndex(fixations[i].x, fixations[i].y, regions);
            
            if (fromRegion >= 0 && toRegion >= 0) {
              matrix[fromRegion][toRegion]++;
            }
          }
          
          return matrix;
        }
      }

      // Initialize coordinate plane for screen
      function initCoordinatePlane() {
        coordinatePlane = document.createElement('div');
        coordinatePlane.id = 'coordinatePlane';
        coordinatePlane.style.position = 'absolute';
        coordinatePlane.style.top = '0';
        coordinatePlane.style.left = '0';
        coordinatePlane.style.width = '100%';
        coordinatePlane.style.height = '100%';
        coordinatePlane.style.pointerEvents = 'none';
        coordinatePlane.style.zIndex = '1000';
        document.body.appendChild(coordinatePlane);
        
        // Create canvas for coordinate plane
        const canvas = document.createElement('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        coordinatePlane.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = config.coordinatePlaneColor;
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        
        // Add coordinate labels
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = x;
          label.style.position = 'absolute';
          label.style.left = `${x}px`;
          label.style.top = '5px';
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = y;
          label.style.position = 'absolute';
          label.style.left = '5px';
          label.style.top = `${y}px`;
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        return coordinatePlane;
      }
      
      // Initialize heatmap layer
      function initHeatmap() {
        if (heatmapLayer) {
          document.body.removeChild(heatmapLayer);
        }
        
        heatmapLayer = document.createElement('canvas');
        heatmapLayer.id = 'heatmapLayer';
        heatmapLayer.width = window.innerWidth;
        heatmapLayer.height = window.innerHeight;
        heatmapLayer.style.position = 'absolute';
        heatmapLayer.style.top = '0';
        heatmapLayer.style.left = '0';
        heatmapLayer.style.pointerEvents = 'none';
        heatmapLayer.style.opacity = config.heatmapOpacity;
        heatmapLayer.style.zIndex = '999';
        document.body.appendChild(heatmapLayer);
        
        return heatmapLayer;
      }
      
      // Update heatmap based on gaze history
      function updateHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure (simple 2D grid)
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Populate grid with gaze data
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            heatGrid[gridY][gridX] += 1;
          }
        });
        
        // Find maximum value for normalization
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        // Draw heatmap
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Head position and tilt calibration
      async function calibrateHeadPosition() {
        ui.statusText.textContent = 'Head Position Calibration...';
        updateProgress(0);
        
        // Create visual guide for head position
        const headGuide = document.createElement('div');
        headGuide.style.position = 'absolute';
        headGuide.style.top = '50%';
        headGuide.style.left = '50%';
        headGuide.style.transform = 'translate(-50%, -50%)';
        headGuide.style.width = '300px';
        headGuide.style.height = '300px';
        headGuide.style.border = '2px dashed white';
        headGuide.style.borderRadius = '50%';
        headGuide.style.zIndex = '1001';
        document.body.appendChild(headGuide);
        
        // Text instructions
        const instructions = document.createElement('div');
        instructions.textContent = 'Position your head in the center and remain still';
        instructions.style.position = 'absolute';
        instructions.style.top = 'calc(50% + 170px)';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.color = 'white';
        instructions.style.fontSize = '18px';
        instructions.style.fontWeight = 'bold';
        instructions.style.zIndex = '1002';
        document.body.appendChild(instructions);
        
        // Collect head position samples
        const samples = [];
        for (let i = 0; i < config.headCalibrationSamples; i++) {
          updateProgress((i / config.headCalibrationSamples) * 100);
          
          // Get current face position from WebGazer
          const currentFace = await new Promise(resolve => {
            webgazer.getCurrentFaceFeatures().then(features => {
              resolve(features);
            });
          });
          
          if (currentFace) {
            samples.push(currentFace);
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Calculate average head position and orientation
        if (samples.length > 0) {
          headCalibrationData = {
            timestamp: Date.now(),
            samples: samples,
            averagePosition: calculateAverageHeadPosition(samples)
          };
          
          showNotification('Head position calibrated successfully');
        } else {
          showNotification('Head calibration failed. Please try again.', true);
        }
        
        // Clean up
        document.body.removeChild(headGuide);
        document.body.removeChild(instructions);
        
        return samples.length > 0;
      }
      
      // Calculate average head position from samples
      function calculateAverageHeadPosition(samples) {
        if (!samples || samples.length === 0) return null;
        
        // Extract comprehensive face metrics for more accurate head position tracking
        const avgPosition = { 
          x: 0, 
          y: 0, 
          width: 0, 
          height: 0,
          rotation: 0,
          confidence: 0,
          eyeDistance: 0,
          faceCenter: { x: 0, y: 0 }
        };
        
        // Count valid samples for accurate averaging
        let validSamples = 0;
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            // Basic position metrics
            avgPosition.x += sample.imagex;
            avgPosition.y += sample.imagey;
            avgPosition.width += sample.width;
            avgPosition.height += sample.height;
            
            // Advanced metrics if available
            if (sample.rotation !== undefined) {
              avgPosition.rotation += sample.rotation;
            }
            
            if (sample.confidence !== undefined) {
              avgPosition.confidence += sample.confidence;
            }
            
            // Calculate eye distance if eye positions are available
            if (sample.eyeLeft && sample.eyeRight) {
              const distance = Math.sqrt(
                Math.pow(sample.eyeRight.x - sample.eyeLeft.x, 2) + 
                Math.pow(sample.eyeRight.y - sample.eyeLeft.y, 2)
              );
              avgPosition.eyeDistance += distance;
              
              // Calculate face center based on eye positions
              avgPosition.faceCenter.x += (sample.eyeLeft.x + sample.eyeRight.x) / 2;
              avgPosition.faceCenter.y += (sample.eyeLeft.y + sample.eyeRight.y) / 2;
            }
            
            validSamples++;
          }
        });
        
        // Use valid sample count for averaging to handle missing data
        const sampleCount = validSamples || 1; // Prevent division by zero
        
        avgPosition.x /= sampleCount;
        avgPosition.y /= sampleCount;
        avgPosition.width /= sampleCount;
        avgPosition.height /= sampleCount;
        avgPosition.rotation /= sampleCount;
        avgPosition.confidence /= sampleCount;
        avgPosition.eyeDistance /= sampleCount;
        avgPosition.faceCenter.x /= sampleCount;
        avgPosition.faceCenter.y /= sampleCount;
        
        // Calculate standard deviation for position stability assessment
        avgPosition.stability = calculatePositionStability(samples, avgPosition);
        
        return avgPosition;
      }
      
      // Helper function to calculate position stability
      function calculatePositionStability(samples, avgPosition) {
        if (!samples || samples.length < 2) return 1.0;
        
        let varianceSum = 0;
        let validSamples = 0;
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            const xDiff = sample.imagex - avgPosition.x;
            const yDiff = sample.imagey - avgPosition.y;
            varianceSum += (xDiff * xDiff) + (yDiff * yDiff);
            validSamples++;
          }
        });
        
        const variance = varianceSum / (validSamples || 1);
        const stdDev = Math.sqrt(variance);
        
        // Convert to stability score (0-1 range, higher is more stable)
        const maxExpectedDeviation = 50; // Pixels
        return Math.max(0, Math.min(1, 1 - (stdDev / maxExpectedDeviation)));
      }
      
      // Start recording session
      async function startRecordingSession() {
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        // Reset eye movement data for new recording
        eyeMovementData = {
          fixations: [],
          saccades: [],
          smoothPursuits: [],
          blinks: []
        };
        gazeMetrics = {};
        recordingStartTime = Date.now();
        lastAnalysisTime = recordingStartTime;
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object with enhanced eye tracking data structures
        recordingSession = {
          id: `session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          // Advanced eye tracking data
          eyeMovements: {
            fixations: [],
            saccades: [],
            smoothPursuits: [],
            blinks: []
          },
          analytics: {}
        };
        
        // Start recording loop
        ui.statusText.textContent = 'Recording in progress...';
        isExperimentRunning = true;
        
        // Start real-time analysis if enabled
        if (config.eyeTracking.realTimeAnalysisEnabled) {
          startRealTimeAnalysis();
        }
        
        const recordingLoop = async () => {
          if (!isExperimentRunning) return;
          
          const elapsedTime = (Date.now() - recordingStartTime) / 1000;
          updateProgress((elapsedTime / config.recordingDuration) * 100);
          
          // Get current gaze prediction
          const prediction = await webgazer.getCurrentPrediction();
          if (prediction) {
            const timestamp = Date.now();
            
            // Add to history for heatmap
            gazeHistory.push({
              x: prediction.x,
              y: prediction.y,
              timestamp: timestamp - recordingStartTime
            });
            
            // Get additional data for advanced analysis
            const headPosition = await webgazer.getCurrentFaceFeatures();
            const trackingQuality = calculateTrackingQuality(headPosition);
            
            // Enhanced frame data
            const enhancedFrame = {
              timestamp: timestamp - recordingStartTime,
              gazeX: prediction.x,
              gazeY: prediction.y,
              headPosition: headPosition,
              trackingQuality: trackingQuality,
              // Add pupil data if available from WebGazer
              pupilData: headPosition?.pupil || null
            };
            
            // Add to recording data
            recordingSession.frames.push(enhancedFrame);
            
            // Draw gaze point with quality indicator
            drawGazePoint(prediction.x, prediction.y, trackingQuality);
            
            // Update heatmap if enabled
            if (heatmapEnabled) {
              enhancedUpdateHeatmap();
            }
            
            // Visualize eye movements if we have data and visualization is enabled
            if (eyeMovementData.fixations.length > 0) {
              visualizeEyeMovements();
            }
          }
          
          // Check if recording duration has been reached
          if (elapsedTime >= config.recordingDuration) {
            stopRecordingSession();
            
            // Perform final comprehensive analysis
            performFinalAnalysis();
            
            showNotification('Recording completed with advanced eye tracking analysis');
            ui.exportContainer.style.display = 'flex';
          } else {
            // Continue loop
            requestAnimationFrame(recordingLoop);
          }
        };
        
        // Start the recording loop
        recordingLoop();
        
        return true;
      }
      
      // Real-time eye movement analysis
      function startRealTimeAnalysis() {
        if (analysisUpdateInterval) {
          clearInterval(analysisUpdateInterval);
        }
        
        analysisUpdateInterval = setInterval(() => {
          if (!isExperimentRunning || isPaused) return;
          
          const now = Date.now();
          // Only analyze data collected since the last analysis
          const recentFrames = recordingSession.frames.filter(
            frame => frame.timestamp > (lastAnalysisTime - recordingStartTime)
          );
          
          if (recentFrames.length >= 10) { // Need minimum data for analysis
            // Format data for analysis
            const analysisData = recentFrames.map(frame => ({
              x: frame.gazeX,
              y: frame.gazeY,
              timestamp: frame.timestamp
            }));
            
            // Detect eye movements using our advanced detection algorithm
            const newMovements = detectEyeMovements(analysisData, {
              fixationMinDuration: config.eyeTracking.fixationSettings.minDuration,
              fixationDispersionThreshold: config.eyeTracking.fixationSettings.dispersionThreshold,
              saccadeVelocityThreshold: config.eyeTracking.saccadeSettings.velocityThreshold,
              blinkMaxGapDuration: config.eyeTracking.blinkSettings.maxGapDuration,
              pursuitVelocityRange: config.eyeTracking.pursuitSettings.velocityRange,
              pursuitDirectionChangeMax: config.eyeTracking.pursuitSettings.directionChangeMax
            });
            
            // Add to our session data with timestamp adjustment
            newMovements.fixations.forEach(fixation => {
              // Adjust timestamps from relative to absolute
              fixation.startTime += recordingStartTime;
              fixation.endTime += recordingStartTime;
              eyeMovementData.fixations.push(fixation);
              recordingSession.eyeMovements.fixations.push(fixation);
            });
            
            newMovements.saccades.forEach(saccade => {
              saccade.startTime += recordingStartTime;
              saccade.endTime += recordingStartTime;
              eyeMovementData.saccades.push(saccade);
              recordingSession.eyeMovements.saccades.push(saccade);
            });
            
            newMovements.smoothPursuits.forEach(pursuit => {
              pursuit.startTime += recordingStartTime;
              pursuit.endTime += recordingStartTime;
              eyeMovementData.smoothPursuits.push(pursuit);
              recordingSession.eyeMovements.smoothPursuits.push(pursuit);
            });
            
            newMovements.blinks.forEach(blink => {
              blink.startTime += recordingStartTime;
              blink.endTime += recordingStartTime;
              eyeMovementData.blinks.push(blink);
              recordingSession.eyeMovements.blinks.push(blink);
            });
            
            // Update statistics and visualizations
            updateEyeMovementStats();
            
            lastAnalysisTime = now;
          }
        }, config.eyeTracking.analysisInterval);
      }
      
      // Update eye movement statistics
      function updateEyeMovementStats() {
        // Update session stats with eye movement metrics
        sessionStats.fixationCount = eyeMovementData.fixations.length;
        sessionStats.saccadeCount = eyeMovementData.saccades.length;
        sessionStats.pursuitCount = eyeMovementData.smoothPursuits.length;
        
        if (eyeMovementData.fixations.length > 0) {
          sessionStats.avgFixationDuration = eyeMovementData.fixations.reduce(
            (sum, f) => sum + f.duration, 0) / eyeMovementData.fixations.length;
        }
        
        if (eyeMovementData.blinks.length > 0 && recordingSession.frames.length > 0) {
          const recordingDuration = (recordingSession.frames[recordingSession.frames.length - 1].timestamp) / 1000; // in seconds
          if (recordingDuration > 0) {
            sessionStats.blinkRate = (eyeMovementData.blinks.length / recordingDuration) * 60; // blinks per minute
          }
        }
      }
      
      // Final comprehensive analysis of eye movement data
      function performFinalAnalysis() {
        if (!recordingSession || recordingSession.frames.length === 0) return;
        
        // Format data for final analysis
        const analysisData = recordingSession.frames.map(frame => ({
          x: frame.gazeX,
          y: frame.gazeY,
          timestamp: frame.timestamp
        }));
        
        // Perform comprehensive analysis
        const analysisResult = analyzeGaze(analysisData);
        
        if (analysisResult.success) {
          recordingSession.analytics = analysisResult.metrics;
          gazeMetrics = analysisResult.metrics;
          
          console.log('Gaze Analysis Results:', {
            fixationCount: gazeMetrics.fixationCount,
            avgFixationDuration: Math.round(gazeMetrics.averageFixationDuration) + 'ms',
            saccadeCount: gazeMetrics.saccadeCount,
            blinkRate: gazeMetrics.blinkRate.toFixed(1) + '/min',
            spatialDensity: gazeMetrics.spatialDensity.toFixed(2) + '%'
          });
        }
      }
      
      // Visualize eye movements
      function visualizeEyeMovements() {
        // Remove existing visualizations
        const existingVisuals = document.querySelectorAll('.eye-movement-visual');
        existingVisuals.forEach(el => el.remove());
        
        // Only proceed if visualization is enabled
        if (!config.eyeTracking.visualization.showFixations && 
            !config.eyeTracking.visualization.showSaccades && 
            !config.eyeTracking.visualization.showPursuits) {
          return;
        }
        
        // Get the most recent data for visualization
        const now = Date.now();
        // Only show eye movements from the last 5 seconds
        const timeWindow = 5000; // 5 seconds
        
        if (config.eyeTracking.visualization.showFixations) {
          // Show recent fixations
          const recentFixations = eyeMovementData.fixations.filter(
            f => f.endTime >= (now - timeWindow)
          );
          
          recentFixations.forEach(fixation => {
            const opacity = Math.min(1, 1 - (now - fixation.endTime) / timeWindow);
            const radius = Math.sqrt(fixation.duration / 100) * config.eyeTracking.visualization.fixationRadiusScale;
            
            const fixationEl = document.createElement('div');
            fixationEl.className = 'eye-movement-visual fixation-visual';
            fixationEl.style.position = 'absolute';
            fixationEl.style.left = `${fixation.x}px`;
            fixationEl.style.top = `${fixation.y}px`;
            fixationEl.style.width = `${radius * 2}px`;
            fixationEl.style.height = `${radius * 2}px`;
            fixationEl.style.borderRadius = '50%';
            fixationEl.style.border = '2px solid rgba(0, 255, 0, ' + opacity + ')';
            fixationEl.style.backgroundColor = 'rgba(0, 255, 0, ' + (opacity * 0.3) + ')';
            fixationEl.style.transform = 'translate(-50%, -50%)';
            fixationEl.style.zIndex = '1002';
            fixationEl.style.pointerEvents = 'none';
            document.body.appendChild(fixationEl);
          });
        }
        
        if (config.eyeTracking.visualization.showSaccades) {
          // Show recent saccades
          const recentSaccades = eyeMovementData.saccades.filter(
            s => s.endTime >= (now - timeWindow)
          );
          
          recentSaccades.forEach(saccade => {
            const opacity = Math.min(1, 1 - (now - saccade.endTime) / timeWindow);
            
            const saccadeLine = document.createElement('div');
            saccadeLine.className = 'eye-movement-visual saccade-visual';
            saccadeLine.style.position = 'absolute';
            saccadeLine.style.left = `${saccade.startX}px`;
            saccadeLine.style.top = `${saccade.startY}px`;
            
            // Calculate line length and angle
            const dx = saccade.endX - saccade.startX;
            const dy = saccade.endY - saccade.startY;
            const length = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            saccadeLine.style.width = `${length}px`;
            saccadeLine.style.height = '2px';
            saccadeLine.style.backgroundColor = `rgba(255, 0, 0, ${opacity})`;
            saccadeLine.style.transformOrigin = '0 0';
            saccadeLine.style.transform = `rotate(${angle}deg)`;
            saccadeLine.style.zIndex = '1001';
            saccadeLine.style.pointerEvents = 'none';
            document.body.appendChild(saccadeLine);
          });
        }
        
        if (config.eyeTracking.visualization.showPursuits) {
          // Show recent smooth pursuits
          const recentPursuits = eyeMovementData.smoothPursuits.filter(
            p => p.endTime >= (now - timeWindow)
          );
          
          recentPursuits.forEach(pursuit => {
            const opacity = Math.min(1, 1 - (now - pursuit.endTime) / timeWindow);
            
            // For pursuits, create a canvas to draw the path
            const canvas = document.createElement('canvas');
            canvas.className = 'eye-movement-visual pursuit-visual';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.zIndex = '1000';
            canvas.style.pointerEvents = 'none';
            document.body.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = `rgba(0, 0, 255, ${opacity})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw lines between all points in the pursuit
            if (pursuit.points && pursuit.points.length > 1) {
              ctx.moveTo(pursuit.points[0].x, pursuit.points[0].y);
              for (let i = 1; i < pursuit.points.length; i++) {
                ctx.lineTo(pursuit.points[i].x, pursuit.points[i].y);
              }
              ctx.stroke();
            }
          });
        }
      }
      
      // Enhanced draw gaze point to visualize quality
      function drawGazePoint(x, y, quality = 1.0) {
        // Remove previous gaze point if exists
        const existingPoint = document.getElementById('currentGazePoint');
        if (existingPoint) {
          document.body.removeChild(existingPoint);
        }
        
        // Calculate color based on quality
        const r = Math.round(255 * (1 - quality));
        const g = Math.round(255 * quality);
        const b = 0;
        const colorQuality = `rgba(${r}, ${g}, ${b}, 0.7)`;
        
        // Create new gaze point
        const gazePoint = document.createElement('div');
        gazePoint.id = 'currentGazePoint';
        gazePoint.style.position = 'absolute';
        gazePoint.style.top = `${y}px`;
        gazePoint.style.left = `${x}px`;
        gazePoint.style.width = '20px';
        gazePoint.style.height = '20px';
        gazePoint.style.borderRadius = '50%';
        gazePoint.style.backgroundColor = colorQuality;
        gazePoint.style.transform = 'translate(-50%, -50%)';
        gazePoint.style.zIndex = '1003';
        gazePoint.style.pointerEvents = 'none';
        document.body.appendChild(gazePoint);
        
        // Add ripple effect
        const ripple = document.createElement('div');
        ripple.style.position = 'absolute';
        ripple.style.top = '50%';
        ripple.style.left = '50%';
        ripple.style.width = '100%';
        ripple.style.height = '100%';
        ripple.style.borderRadius = '50%';
        ripple.style.backgroundColor = colorQuality.replace('0.7', '0.3');
        ripple.style.transform = 'translate(-50%, -50%) scale(1)';
        ripple.style.transition = 'all 0.5s ease-out';
        gazePoint.appendChild(ripple);
        
        setTimeout(() => {
          ripple.style.transform = 'translate(-50%, -50%) scale(2)';
          ripple.style.opacity = '0';
        }, 10);
      }
      
      // Enhanced updateHeatmap that also uses eye movement data
      function enhancedUpdateHeatmap() {
        if (!heatmapLayer || !heatmapEnabled) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // If we have fixation data, use that for the heatmap
        if (eyeMovementData.fixations.length > 0 && realTimeAnalysisEnabled) {
          // Create heatmap from fixations (weighted by duration)
          const gridSize = config.heatmapResolution;
          const cellWidth = heatmapLayer.width / gridSize;
          const cellHeight = heatmapLayer.height / gridSize;
          const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
          
          // Get only recent fixations (last 10 seconds)
          const now = Date.now();
          const timeWindow = 10000; // 10 seconds
          const recentFixations = eyeMovementData.fixations.filter(
            f => f.endTime >= (now - timeWindow)
          );
          
          // Weight by duration and recency
          recentFixations.forEach(fixation => {
            const gridX = Math.floor(fixation.x / cellWidth);
            const gridY = Math.floor(fixation.y / cellHeight);
            
            // Apply temporal decay - newer fixations have more weight
            const age = (now - fixation.endTime) / timeWindow;
            const recencyWeight = Math.max(0, 1 - age);
            
            // Apply duration weight - longer fixations have more weight
            const durationWeight = Math.min(1, fixation.duration / 500); // Normalize to 0-1
            
            // Combined weight
            const weight = recencyWeight * durationWeight;
            
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
              heatGrid[gridY][gridX] += weight;
            }
          });
          
          // Find maximum value for normalization
          let maxVal = 1;
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              maxVal = Math.max(maxVal, heatGrid[y][x]);
            }
          }
          
          // Draw heatmap
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const intensity = heatGrid[y][x] / maxVal;
              if (intensity > 0) {
                const colorIndex = Math.min(
                  Math.floor(intensity * config.heatmapColorScale.length),
                  config.heatmapColorScale.length - 1
                );
                
                ctx.fillStyle = config.heatmapColorScale[colorIndex];
                ctx.beginPath();
                ctx.arc(
                  x * cellWidth + cellWidth / 2,
                  y * cellHeight + cellHeight / 2,
                  config.heatmapRadius * Math.sqrt(intensity),
                  0, 2 * Math.PI
                );
                ctx.fill();
              }
            }
          }
        } else {
          // Fall back to the original heatmap method using raw gaze data
          if (gazeHistory.length === 0) return;
          
          // Create heatmap data structure (simple 2D grid)
          const gridSize = config.heatmapResolution;
          const cellWidth = heatmapLayer.width / gridSize;
          const cellHeight = heatmapLayer.height / gridSize;
          const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
          
          // Populate grid with gaze data
          gazeHistory.forEach(point => {
            if (!point || point.x === undefined || point.y === undefined) return;
            
            const gridX = Math.floor(point.x / cellWidth);
            const gridY = Math.floor(point.y / cellHeight);
            
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
              heatGrid[gridY][gridX] += 1;
            }
          });
          
          // Find maximum value for normalization
          let maxVal = 1;
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              maxVal = Math.max(maxVal, heatGrid[y][x]);
            }
          }
          
          // Draw heatmap
          for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
              const intensity = heatGrid[y][x] / maxVal;
              if (intensity > 0) {
                const colorIndex = Math.min(
                  Math.floor(intensity * config.heatmapColorScale.length),
                  config.heatmapColorScale.length - 1
                );
                
                ctx.fillStyle = config.heatmapColorScale[colorIndex];
                ctx.beginPath();
                ctx.arc(
                  x * cellWidth + cellWidth / 2,
                  y * cellHeight + cellHeight / 2,
                  config.heatmapRadius * Math.sqrt(intensity),
                  0, 2 * Math.PI
                );
                ctx.fill();
              }
            }
          }
        }
      }
      
      // Stop recording session
      function stopRecordingSession() {
        isExperimentRunning = false;
        
        if (recordingSession) {
          recordingSession.endTime = Date.now();
          recordingSession.duration = recordingSession.endTime - recordingSession.startTime;
          
          // Save recording data
          gazeData = recordingSession.frames;
          
          // Clean up
          if (coordinatePlane) {
            document.body.removeChild(coordinatePlane);
            coordinatePlane = null;
          }
          
          if (heatmapLayer) {
            document.body.removeChild(heatmapLayer);
            heatmapLayer = null;
          }
          
          ui.statusText.textContent = 'Recording stopped';
          updateProgress(100);
          
          // Stop auto-save interval if running
          if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
          }
          
          // Stop inactivity timer if running
          if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
          }
        }
      }
      
      // Toggle heatmap visibility
      function toggleHeatmap() {
        heatmapEnabled = !heatmapEnabled;
        
        if (heatmapEnabled) {
          if (!heatmapLayer) {
            initHeatmap();
          }
          updateHeatmap();
          showNotification('Heatmap enabled');
        } else {
          if (heatmapLayer) {
            const ctx = heatmapLayer.getContext('2d');
            ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
          }
          showNotification('Heatmap disabled');
        }
      }
      
      // Export recording data
      function exportRecordingData() {
        console.log('Starting export of recording data...');
        
        if (!recordingSession || recordingSession.frames.length === 0) {
          console.error('Export failed: No recording data available');
          showNotification('No recording data available', true);
          return;
        }
        
        console.log(`Preparing to export ${recordingSession.frames.length} frames of data`);
        
        try {
          // Prepare CSV data for raw gaze points
          console.log('Generating CSV content...');
          const csvContent = "data:text/csv;charset=utf-8," + 
            "timestamp,gazeX,gazeY,headX,headY,headWidth,headHeight,trackingQuality\n" +
            recordingSession.frames.map(frame => {
              const head = frame.headPosition || {};
              return `${frame.timestamp},${frame.gazeX},${frame.gazeY},` +
                     `${head.imagex || ''},${head.imagey || ''},` +
                     `${head.width || ''},${head.height || ''},` +
                     `${frame.trackingQuality || '1.0'}`;
            }).join("\n");
          
          console.log('CSV content generated successfully');
          
          // Create download link for raw data
          const csvLink = document.createElement('a');
          csvLink.href = encodeURI(csvContent);
          csvLink.download = `gaze_recording_${recordingSession.id}.csv`;
          console.log(`Initiating CSV download: gaze_recording_${recordingSession.id}.csv`);
          csvLink.click();
          
          // Generate enhanced CSV for eye movements
          if (eyeMovementData.fixations.length > 0) {
            console.log('Generating enhanced eye movement CSV...');
            
            // Fixations CSV
            const fixationsCSV = "data:text/csv;charset=utf-8," + 
              "id,startTime,endTime,duration,x,y,dispersion\n" +
              eyeMovementData.fixations.map((fix, idx) => 
                `${idx},${fix.startTime - recordingStartTime},${fix.endTime - recordingStartTime},` +
                `${fix.duration},${fix.x},${fix.y},${fix.dispersion || ''}`
              ).join("\n");
            
            const fixationLink = document.createElement('a');
            fixationLink.href = encodeURI(fixationsCSV);
            fixationLink.download = `fixations_${recordingSession.id}.csv`;
            console.log(`Initiating fixations CSV download`);
            fixationLink.click();
            
            // Saccades CSV if we have saccade data
            if (eyeMovementData.saccades.length > 0) {
              const saccadesCSV = "data:text/csv;charset=utf-8," + 
                "id,startTime,endTime,duration,startX,startY,endX,endY,amplitude,peakVelocity,direction\n" +
                eyeMovementData.saccades.map((sacc, idx) => 
                  `${idx},${sacc.startTime - recordingStartTime},${sacc.endTime - recordingStartTime},` +
                  `${sacc.duration},${sacc.startX},${sacc.startY},${sacc.endX},${sacc.endY},` +
                  `${sacc.amplitude},${sacc.peakVelocity},${sacc.direction}`
                ).join("\n");
              
              const saccadeLink = document.createElement('a');
              saccadeLink.href = encodeURI(saccadesCSV);
              saccadeLink.download = `saccades_${recordingSession.id}.csv`;
              console.log(`Initiating saccades CSV download`);
              saccadeLink.click();
            }
          }
          
          // Prepare comprehensive JSON data
          console.log('Generating enhanced JSON content...');
          const jsonData = {
            sessionInfo: {
              id: recordingSession.id,
              startTime: recordingSession.startTime,
              endTime: recordingSession.startTime + 
                       recordingSession.frames[recordingSession.frames.length - 1].timestamp,
              duration: recordingSession.frames[recordingSession.frames.length - 1].timestamp,
              screenDimensions: recordingSession.screenDimensions
            },
            headCalibration: recordingSession.headCalibration,
            frames: recordingSession.frames,
            // Include advanced eye tracking data
            eyeMovements: recordingSession.eyeMovements,
            analytics: recordingSession.analytics || gazeMetrics
          };
          
          console.log('JSON object created with session metadata and eye movement data');
          
          const jsonContent = "data:text/json;charset=utf-8," + 
            encodeURIComponent(JSON.stringify(jsonData));
          
          // Create download link
          const jsonLink = document.createElement('a');
          jsonLink.href = jsonContent;
          jsonLink.download = `gaze_recording_enhanced_${recordingSession.id}.json`;
          console.log(`Initiating enhanced JSON download: gaze_recording_enhanced_${recordingSession.id}.json`);
          jsonLink.click();
          
          console.log('Export completed successfully with enhanced eye movement data');
          showNotification('Recording data exported with eye movement analysis');
        } catch (error) {
          console.error('Export failed with error:', error);
          showNotification('Export failed: ' + error.message, true);
        }
      }
      
      // Generate session summary at the end
      function generateSessionSummary() {
        // Create a printable summary
        const summary = {
          sessionId: recordingSession?.id,
          duration: {
            total: formatTime(sessionStats.totalDuration),
            active: formatTime(sessionStats.activeDuration),
            paused: formatTime(sessionStats.pauseDuration)
          },
          segments: sessionStats.segmentCount,
          dataPoints: sessionStats.dataPoints,
          avgQuality: `${Math.round(sessionStats.avgTrackingQuality * 100)}%`,
          timestamp: new Date().toISOString()
        };
        
        console.log('Session Summary:', summary);
        return summary;
      }

      // Export data
      function exportData() {
        console.log('Starting export of experiment data...');
        
        if (!gazeData || gazeData.length === 0) {
          console.error('Export failed: No gaze data available');
          showNotification('No data available to export', true);
          return;
        }
        
        try {
          // Basic CSV Export of raw gaze data
          console.log('Generating CSV content...');
          const csvContent = "data:text/csv;charset=utf-8," + 
            "timestamp,x,y,trial\n" +
            gazeData.map(row => 
              `${row.timestamp},${row.x},${row.y},${row.trial}`
            ).join("\n");

          const csvLink = document.createElement('a');
          csvLink.href = encodeURI(csvContent);
          csvLink.download = 'gaze_data.csv';
          console.log('Initiating CSV download: gaze_data.csv');
          csvLink.click();

          // Basic JSON Export of raw data
          console.log('Generating JSON content...');
          const jsonContent = "data:text/json;charset=utf-8," + 
            encodeURIComponent(JSON.stringify(gazeData));

          const jsonLink = document.createElement('a');
          jsonLink.href = jsonContent;
          jsonLink.download = 'gaze_data.json';
          console.log('Initiating JSON download: gaze_data.json');
          jsonLink.click();
          
          // Export enhanced eye movement data if available
          if (eyeMovementData && (eyeMovementData.fixations.length > 0 || eyeMovementData.saccades.length > 0)) {
            console.log('Generating enhanced eye movement data exports...');
            
            // Enhanced analysis JSON with all eye movement data
            const enhancedData = {
              session: {
                id: recordingSession?.id || `session_${Date.now()}`,
                duration: recordingSession?.frames?.[recordingSession.frames.length - 1]?.timestamp || 0,
                screenDimensions: {
                  width: window.innerWidth,
                  height: window.innerHeight
                }
              },
              eyeMovements: eyeMovementData,
              metrics: gazeMetrics
            };
            
            const enhancedJson = "data:text/json;charset=utf-8," + 
              encodeURIComponent(JSON.stringify(enhancedData));
            
            const enhancedJsonLink = document.createElement('a');
            enhancedJsonLink.href = enhancedJson;
            enhancedJsonLink.download = 'eye_movement_analysis.json';
            console.log('Initiating enhanced analysis download: eye_movement_analysis.json');
            enhancedJsonLink.click();
            
            // Export separate CSVs for each eye movement type
            if (eyeMovementData.fixations.length > 0) {
              // Fixations CSV
              const fixationsCSV = "data:text/csv;charset=utf-8," + 
                "id,startTime,endTime,duration,x,y,dispersion\n" +
                eyeMovementData.fixations.map((fix, idx) => 
                  `${idx},${fix.startTime},${fix.endTime},` +
                  `${fix.duration},${fix.x},${fix.y},${fix.dispersion || ''}`
                ).join("\n");
              
              const fixationLink = document.createElement('a');
              fixationLink.href = encodeURI(fixationsCSV);
              fixationLink.download = 'fixations.csv';
              console.log('Initiating fixations CSV download');
              fixationLink.click();
            }
            
            if (eyeMovementData.saccades.length > 0) {
              // Saccades CSV
              const saccadesCSV = "data:text/csv;charset=utf-8," + 
                "id,startTime,endTime,duration,startX,startY,endX,endY,amplitude,peakVelocity,direction\n" +
                eyeMovementData.saccades.map((sacc, idx) => 
                  `${idx},${sacc.startTime},${sacc.endTime},` +
                  `${sacc.duration},${sacc.startX},${sacc.startY},${sacc.endX},${sacc.endY},` +
                  `${sacc.amplitude},${sacc.peakVelocity},${sacc.direction}`
                ).join("\n");
              
              const saccadeLink = document.createElement('a');
              saccadeLink.href = encodeURI(saccadesCSV);
              saccadeLink.download = 'saccades.csv';
              console.log('Initiating saccades CSV download');
              saccadeLink.click();
            }
          }
          
          console.log('Export completed successfully');
          showNotification('Data exported successfully with eye movement analysis');
        } catch (error) {
          console.error('Export failed with error:', error);
          showNotification('Export failed: ' + error.message, true);
        }
      }

      // Set up event listeners
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize UI elements if they were not found earlier
        if (!ui.startBtn) ui.startBtn = document.getElementById('startBtn');
        if (!ui.calibrateBtn) ui.calibrateBtn = document.getElementById('calibrateBtn');
        if (!ui.abortBtn) ui.abortBtn = document.getElementById('abortBtn');
        
        console.log('Setting up button event listeners...');
        
        // Start button
        if (ui.startBtn) {
          ui.startBtn.addEventListener('click', async function() {
            console.log('Start button clicked');
            
            // Check if WebGazer is initialized
            let isWebGazerReady = await initializeWebGazer();
            if (!isWebGazerReady) {
              showNotification('Failed to initialize WebGazer', true);
              return;
            }
            
            // Check if PsychoJS is initialized
            let isPsychoJSReady = initializePsychoJS();
            if (!isPsychoJSReady) {
              showNotification('Failed to initialize PsychoJS', true);
              return;
            }
            
            // Start experiment
            startExperiment();
          });
          console.log('Start button listener attached');
        } else {
          console.error('Start button not found in the DOM');
        }
        
        // Calibrate button
        if (ui.calibrateBtn) {
          ui.calibrateBtn.addEventListener('click', async function() {
            console.log('Calibrate button clicked');
            
            // Check if WebGazer is initialized
            let isWebGazerReady = await initializeWebGazer();
            if (!isWebGazerReady) {
              showNotification('Failed to initialize WebGazer', true);
              return;
            }
            
            // Check if PsychoJS is initialized
            let isPsychoJSReady = initializePsychoJS();
            if (!isPsychoJSReady) {
              showNotification('Failed to initialize PsychoJS', true);
              return;
            }
            
            // Start calibration
            ui.statusText.textContent = 'Starting calibration...';
            runCalibration();
          });
          console.log('Calibrate button listener attached');
        } else {
          console.error('Calibrate button not found in the DOM');
        }
        
        // Abort button
        if (ui.abortBtn) {
          ui.abortBtn.addEventListener('click', function() {
            console.log('Abort button clicked');
            stopExperiment();
            ui.statusText.textContent = 'Experiment aborted';
          });
          console.log('Abort button listener attached');
        } else {
          console.error('Abort button not found in the DOM');
        }
        
        // Apply settings button
        const applySettingsBtn = document.getElementById('applySettingsBtn');
        if (applySettingsBtn) {
          applySettingsBtn.addEventListener('click', function() {
            console.log('Apply settings button clicked');
            applySettings();
          });
          console.log('Apply settings button listener attached');
        }
        
        console.log('Event listeners setup complete');
      });
    </script>
  </body>
</html>