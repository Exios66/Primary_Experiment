<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Advanced Eye Tracking Experiment</title>
    
    <!-- Modern dependencies -->
    <script src="https://unpkg.com/psychojs@2023.2.3/dist/psychojs.js" onerror="loadLocalPsychoJS()"></script>
    <script src="webgazer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <script>
      // Fallback for loading PsychoJS locally
      function loadLocalPsychoJS() {
        console.warn("Loading PsychoJS from CDN failed, attempting to load local version...");
        const script = document.createElement('script');
        script.src = "psychojs.js"; // Ensure you have a local copy of psychojs.js
        script.onerror = function() {
          console.error("Failed to load local PsychoJS. Please make sure 'psychojs.js' exists in the same directory.");
          alert("Failed to load PsychoJS. The experiment may not work correctly.");
        };
        document.head.appendChild(script);
      }
    </script>
    
    <style>
      :root {
        --primary-color: #2563eb;
        --secondary-color: #1e40af;
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --error-color: #ef4444;
        --success-color: #22c55e;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .experiment-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 2rem;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        background: var(--primary-color);
        color: white;
      }

      .btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        height: 8px;
        margin: 1rem 0;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: var(--primary-color);
        transition: width 0.3s ease;
        width: 0%;
      }

      .calibration-point {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .export-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        margin-top: 2rem;
      }

      .export-btn {
        background: transparent;
        border: 2px solid var(--primary-color);
        color: var(--text-color);
      }

      .export-btn:hover {
        background: var(--primary-color);
      }

      .notification {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        padding: 1rem;
        border-radius: 6px;
        background: var(--success-color);
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .notification.show {
        opacity: 1;
      }

      .error {
        background: var(--error-color);
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .controls {
          flex-direction: column;
        }
      }
      
      /* Long duration session styles */
      .session-stats {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        display: none;
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        margin-top: 0.5rem;
      }
      
      .stat-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.75rem;
        border-radius: 4px;
        text-align: center;
      }
      
      .stat-value {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--primary-color);
      }
      
      .stat-label {
        font-size: 0.8rem;
        opacity: 0.7;
      }
      
      .segment-indicator {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 1rem;
      }
      
      .segment-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
      }
      
      .segment-dot.active {
        background: var(--primary-color);
      }
      
      .segment-dot.completed {
        background: var(--success-color);
      }
      
      .long-duration-controls {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        flex-wrap: wrap;
        justify-content: center;
        display: none;
      }
      
      .settings-panel {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 1.5rem;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      }
      
      .settings-group {
        margin-bottom: 1.5rem;
      }
      
      .settings-group h3 {
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 0.5rem;
      }
      
      .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 0.75rem;
      }
      
      .form-row label {
        flex: 1;
      }
      
      .form-row input, .form-row select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.5rem;
        border-radius: 4px;
        color: var(--text-color);
        width: 120px;
      }
      
      .close-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        color: var(--text-color);
        font-size: 1.5rem;
        cursor: pointer;
        opacity: 0.7;
      }
      
      .close-btn:hover {
        opacity: 1;
      }
      
      .pause-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 2rem;
        border-radius: 8px;
        text-align: center;
        z-index: 1100;
        display: none;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }
      
      .pause-indicator h2 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      
      .pulse {
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }
      
      .quality-indicator {
        position: fixed;
        top: 1rem;
        right: 1rem;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--success-color);
        z-index: 1000;
      }
      
      .quality-indicator.medium {
        background: orange;
      }
      
      .quality-indicator.low {
        background: var(--error-color);
      }
      
      /* Timeline visualization for long sessions */
      .timeline {
        height: 2rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        margin-top: 1rem;
        position: relative;
        overflow: hidden;
      }
      
      .timeline-segment {
        position: absolute;
        height: 100%;
        background: var(--primary-color);
        opacity: 0.6;
      }
      
      .timeline-cursor {
        position: absolute;
        width: 2px;
        height: 100%;
        background: white;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Eye Tracking Experiment</h1>
        <p>Advanced gaze tracking using WebGazer.js and PsychoJS</p>
      </div>

      <div class="experiment-status">
        <h2>Status</h2>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <p id="statusText">Initializing experiment...</p>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn" type="button">Start Experiment</button>
        <button class="btn" id="calibrateBtn" type="button" disabled>Calibrate</button>
        <button class="btn" id="abortBtn" type="button" disabled>Stop Experiment</button>
      </div>

      <div class="long-duration-controls" id="longDurationControls">
        <button class="btn" id="startLongSessionBtn" type="button">Start Long Session</button>
        <button class="btn" id="pauseResumeBtn" type="button" disabled>Pause</button>
        <button class="btn" id="settingsBtn" type="button">Settings</button>
        <button class="btn" id="saveSegmentBtn" type="button" disabled>Save Segment</button>
      </div>
      
      <div class="session-stats" id="sessionStats">
        <h3>Long Duration Session Statistics</h3>
        <div class="timeline" id="sessionTimeline">
          <div class="timeline-cursor" id="timelineCursor"></div>
        </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="totalTimeValue">00:00:00</div>
            <div class="stat-label">Total Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="activeTimeValue">00:00:00</div>
            <div class="stat-label">Active Recording</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="pauseTimeValue">00:00:00</div>
            <div class="stat-label">Pause Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="dataPointsValue">0</div>
            <div class="stat-label">Data Points</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="trackingQualityValue">100%</div>
            <div class="stat-label">Tracking Quality</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="segmentCountValue">0</div>
            <div class="stat-label">Segments</div>
          </div>
        </div>
        <div class="segment-indicator" id="segmentIndicator"></div>
      </div>

      <div id="experimentContainer"></div>

      <div class="export-container" id="exportContainer" style="display: none;">
        <button class="btn export-btn" id="exportCSV" type="button">Download CSV Data</button>
        <button class="btn export-btn" id="exportJSON" type="button">Download JSON Data</button>
        <button class="btn export-btn" id="exportAllSegments" type="button">Download All Segments</button>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-btn" id="closeSettingsBtn" type="button">&times;</button>
        <h2>Long Duration Session Settings</h2>
        
        <div class="settings-group">
          <h3>Session Duration</h3>
          <div class="form-row">
            <label for="sessionDurationHours">Session Length (hours)</label>
            <input type="number" id="sessionDurationHours" min="0.1" max="24" step="0.1" value="1">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Segmentation</h3>
          <div class="form-row">
            <label for="segmentDuration">Segment Length (minutes)</label>
            <input type="number" id="segmentDuration" min="1" max="60" step="1" value="10">
          </div>
          <div class="form-row">
            <label for="autoSaveInterval">Auto-save Interval (minutes)</label>
            <input type="number" id="autoSaveInterval" min="1" max="30" step="1" value="5">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Memory Management</h3>
          <div class="form-row">
            <label for="maxGazePoints">Max Points in Memory</label>
            <input type="number" id="maxGazePoints" min="1000" max="100000" step="1000" value="10000">
          </div>
          <div class="form-row">
            <label for="downsamplingFactor">Downsampling Factor</label>
            <select id="downsamplingFactor">
              <option value="1">None (1x)</option>
              <option value="2">Light (2x)</option>
              <option value="5">Medium (5x)</option>
              <option value="10">Heavy (10x)</option>
            </select>
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Auto-pause Detection</h3>
          <div class="form-row">
            <label for="pauseDetectionEnabled">Enable Auto-pause</label>
            <input type="checkbox" id="pauseDetectionEnabled" checked>
          </div>
          <div class="form-row">
            <label for="inactivityThreshold">Inactivity Threshold (seconds)</label>
            <input type="number" id="inactivityThreshold" min="5" max="120" step="5" value="30">
          </div>
        </div>
        
        <button class="btn" id="applySettingsBtn" type="button">Apply Settings</button>
      </div>
      
      <div class="pause-indicator" id="pauseIndicator">
        <h2 class="pulse">Recording Paused</h2>
        <p>Press resume to continue recording</p>
      </div>
      
      <div class="quality-indicator" id="qualityIndicator"></div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
      // Global state
      let psychoJS;
      let experimentWindow;
      let gazeData = [];
      let calibrationData = [];
      let isExperimentRunning = false;
      let currentTrial = 0;
      let heatmapEnabled = false;
      let recordingSession = null;
      let headCalibrationData = null;
      let coordinatePlane = null;
      let heatmapLayer = null;
      let gazeHistory = [];
      let recordingStartTime = null;
      // Long duration session variables
      let isLongDurationSession = false;
      let currentSegment = 0;
      let segmentStartTime = null;
      let isPaused = false;
      let pauseStartTime = null;
      let totalPausedTime = 0;
      let autoSaveInterval = null;
      let lastCleanupTime = null;
      let recordedSegments = [];
      let currentRecordingTime = 0;
      let lastTrackingQuality = 1.0;
      let inactivityTimer = null;
      // Advanced eye tracking state
      let eyeMovementData = {
        fixations: [],
        saccades: [],
        smoothPursuits: [],
        blinks: []
      };
      let gazeMetrics = {};
      let realTimeAnalysisEnabled = true;
      let analysisUpdateInterval = null;
      let lastAnalysisTime = 0;
      let eyeMovementVisualization = {
        showFixations: true,
        showSaccades: false,
        showPursuits: false,
        fixationRadiusScale: 0.5   // Scale factor for fixation circles
      };
      let sessionStats = {
        totalDuration: 0,
        activeDuration: 0,
        pauseDuration: 0,
        dataPoints: 0,
        avgTrackingQuality: 1.0,
        segmentCount: 0,
        // New advanced metrics
        fixationCount: 0,
        avgFixationDuration: 0,
        saccadeCount: 0,
        blinkRate: 0,
        pursuitCount: 0
      };

      // Configuration
      const config = {
        fullscreen: true,
        backgroundColor: '#0f172a',
        frameRate: 60,
        calibrationPoints: 9,
        trialCount: 5,
        sampleRate: 30,
        heatmapResolution: 50,
        heatmapOpacity: 0.6,
        heatmapRadius: 50,
        heatmapColorScale: ['blue', 'green', 'yellow', 'red'],
        coordinatePlaneColor: 'rgba(255, 255, 255, 0.2)',
        coordinatePlaneSpacing: 50,
        recordingDuration: 60, // seconds
        headCalibrationSamples: 30,
        // Long duration session options
        longDurationEnabled: false,
        longDurationHours: 1, // Default 1 hour for long sessions
        segmentDuration: 10 * 60, // 10 minutes per segment
        autoSaveInterval: 5 * 60, // Auto-save every 5 minutes
        memoryManagement: {
          maxGazeHistoryPoints: 10000, // Maximum points to keep in memory
          cleanupInterval: 60, // Cleanup every 1 minute
          sampleDownsamplingFactor: 1 // No downsampling by default
        },
        pauseDetection: {
          enabled: true,
          inactivityThreshold: 30, // Seconds of inactivity before pausing
          lowQualityThreshold: 0.4 // Threshold for low quality tracking
        },
        visualization: {
          timeWindow: 60, // Show last 60 seconds in visualizations by default
          heatmapTemporalDecay: 0.9 // Decay factor for older points
        }
      };

      // UI Elements
      const ui = {
        startBtn: document.getElementById('startBtn'),
        calibrateBtn: document.getElementById('calibrateBtn'),
        abortBtn: document.getElementById('abortBtn'),
        progressBar: document.getElementById('progressBar'),
        statusText: document.getElementById('statusText'),
        notification: document.getElementById('notification'),
        exportContainer: document.getElementById('exportContainer')
      };

      // Initialize WebGazer
      async function initializeWebGazer() {
        try {
          ui.statusText.textContent = 'Initializing WebGazer...';
          updateProgress(10);
          
          await webgazer.setGazeListener((data, timestamp) => {
            if (data && isExperimentRunning) {
              gazeData.push({
                timestamp,
                x: data.x,
                y: data.y,
                trial: currentTrial
              });
            }
          }).begin();
          
          updateProgress(50);
          ui.statusText.textContent = 'WebGazer initialized successfully';
      
          // Configure WebGazer
          webgazer.showVideo(false)
                   .showFaceOverlay(false)
                   .showFaceFeedbackBox(false)
                   .showPredictionPoints(false);

          updateProgress(75);
          return true;
        } catch (error) {
          console.error("WebGazer initialization failed:", error);
          showNotification('Failed to initialize WebGazer: ' + error.message, true);
          return false;
        }
      }

      // Initialize PsychoJS
      function initializePsychoJS() {
        try {
          // Check if PsychoJS is defined
          if (typeof PsychoJS === 'undefined') {
            console.error("PsychoJS is not defined. Make sure the library is loaded correctly.");
            showNotification("PsychoJS library failed to load", true);
            return false;
          }
          
          psychoJS = new PsychoJS({
            debug: true
          });

          experimentWindow = new psychoJS.visual.Window({
            size: [window.innerWidth, window.innerHeight],
            fullscr: config.fullscreen,
            color: new psychoJS.Color(config.backgroundColor),
            units: 'norm'
          });
          
          updateProgress(25); // Update progress to indicate successful initialization
          return true;
        } catch (error) {
          console.error("Error initializing PsychoJS:", error);
          showNotification("Failed to initialize PsychoJS: " + error.message, true);
          return false;
        }
      }

      // Calibration procedure
      async function runCalibration() {
        const points = [
          [-0.8, 0.8], [0, 0.8], [0.8, 0.8],
          [-0.8, 0], [0, 0], [0.8, 0],
          [-0.8, -0.8], [0, -0.8], [0.8, -0.8]
        ];

        calibrationData = [];
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          
          // Create calibration point
          const dot = new psychoJS.visual.Circle({
            win: experimentWindow,
            radius: 0.02,
            pos: point,
            fillColor: new psychoJS.Color('white'),
            lineWidth: 0
          });

          // Show point
          dot.draw();
          experimentWindow.flip();

          // Wait for fixation
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Collect samples
          const samples = [];
          for (let j = 0; j < 10; j++) {
            const prediction = await webgazer.getCurrentPrediction();
            if (prediction) {
              samples.push({
                x: prediction.x,
                y: prediction.y
              });
            }
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          // Calculate average
          if (samples.length > 0) {
            const avgX = samples.reduce((sum, s) => sum + s.x, 0) / samples.length;
            const avgY = samples.reduce((sum, s) => sum + s.y, 0) / samples.length;
            
            calibrationData.push({
              target: point,
              measured: [avgX, avgY]
            });
          }

          // Update progress
          updateProgress((i + 1) / points.length * 100);
        }

        // Assess calibration quality
        const calibrationQuality = assessCalibrationQuality(calibrationData);
        if (calibrationQuality.score < 0.6) {
          showNotification(`Calibration quality is low (${Math.round(calibrationQuality.score * 100)}%). Consider recalibrating.`, true);
        } else {
          showNotification(`Calibration quality: ${Math.round(calibrationQuality.score * 100)}%`);
        }

        return calibrationData.length === points.length;
      }

      // Advanced calibration quality assessment
      function assessCalibrationQuality(calibrationData) {
        if (!calibrationData || calibrationData.length === 0) {
          return { score: 0, details: "No calibration data available" };
        }
        
        // Convert normalized coordinates to pixel coordinates for easier interpretation
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        // Calculate error metrics for each calibration point
        const pointErrors = calibrationData.map(point => {
          // Convert normalized target coordinates to pixels
          const targetX = ((point.target[0] + 1) / 2) * screenWidth;
          const targetY = ((point.target[1] + 1) / 2) * screenHeight;
          
          // Measured coordinates are already in pixels
          const measuredX = point.measured[0];
          const measuredY = point.measured[1];
          
          // Calculate Euclidean distance error
          const error = Math.sqrt(
            Math.pow(targetX - measuredX, 2) + 
            Math.pow(targetY - measuredY, 2)
          );
          
          return {
            target: [targetX, targetY],
            measured: [measuredX, measuredY],
            error: error
          };
        });
        
        // Calculate overall metrics
        const totalError = pointErrors.reduce((sum, p) => sum + p.error, 0);
        const avgError = totalError / pointErrors.length;
        const maxError = Math.max(...pointErrors.map(p => p.error));
        
        // Calculate standard deviation of errors
        const errorVariance = pointErrors.reduce((sum, p) => sum + Math.pow(p.error - avgError, 2), 0) / pointErrors.length;
        const errorStdDev = Math.sqrt(errorVariance);
        
        // Calculate normalized quality score (0-1, higher is better)
        // We'll use a sigmoid function to map average error to a quality score
        // Typical screen diagonal is used as a reference for normalizing error
        const screenDiagonal = Math.sqrt(Math.pow(screenWidth, 2) + Math.pow(screenHeight, 2));
        const normalizedAvgError = avgError / (screenDiagonal * 0.1); // 10% of screen diagonal as reference
        const qualityScore = 1 / (1 + Math.exp((normalizedAvgError - 1) * 5));
        
        return {
          score: qualityScore,
          avgError: avgError,
          maxError: maxError,
          stdDev: errorStdDev,
          pointErrors: pointErrors,
          uniformity: 1 - (errorStdDev / avgError) // Higher value means more uniform errors
        };
      }

      // Advanced gaze data filtering
      function filterGazeData(rawData, options = {}) {
        if (!rawData || rawData.length === 0) return [];
        
        const defaults = {
          outlierThreshold: 2.5, // Standard deviations for outlier detection
          velocityThreshold: 1000, // pixels/second for saccade detection
          medianFilterSize: 3, // Window size for median filter
          smoothingFactor: 0.2, // For exponential smoothing (0-1)
          jitterRadius: 10, // pixels, for jitter detection
          minSampleDistance: 5, // Min distance between consecutive samples to keep
          timeWindow: 100 // ms, time window for velocity calculation
        };
        
        const settings = { ...defaults, ...options };
        let filteredData = [...rawData];
        
        // Step 1: Remove missing or invalid values
        filteredData = filteredData.filter(d => 
          d && d.x !== undefined && !isNaN(d.x) && 
          d.y !== undefined && !isNaN(d.y) && 
          d.timestamp !== undefined
        );
        
        if (filteredData.length === 0) return [];
        
        // Step 2: Outlier removal using Median Absolute Deviation (more robust than std dev)
        if (filteredData.length > 5) {
          // Calculate median positions
          const xValues = filteredData.map(d => d.x);
          const yValues = filteredData.map(d => d.y);
          
          const medianX = calculateMedian(xValues);
          const medianY = calculateMedian(yValues);
          
          // Calculate deviations
          const xDeviations = xValues.map(x => Math.abs(x - medianX));
          const yDeviations = yValues.map(y => Math.abs(y - medianY));
          
          // Calculate MAD
          const madX = calculateMedian(xDeviations);
          const madY = calculateMedian(yDeviations);
          
          // Filter using MAD outlier detection (more robust than z-score)
          filteredData = filteredData.filter((d, i) => {
            const xDevScore = xDeviations[i] / (madX || 1); // Avoid division by zero
            const yDevScore = yDeviations[i] / (madY || 1);
            return xDevScore < settings.outlierThreshold && yDevScore < settings.outlierThreshold;
          });
        }
        
        // Step 3: Velocity-based filtering (for saccade detection)
        if (filteredData.length > 2) {
          const velocityFiltered = [];
          
          for (let i = 1; i < filteredData.length; i++) {
            const current = filteredData[i];
            const prev = filteredData[i-1];
            
            // Calculate time difference in seconds
            const dt = (current.timestamp - prev.timestamp) / 1000;
            
            // Skip if time difference is too small or zero to avoid division by zero
            if (dt <= 0.001) {
              velocityFiltered.push(current);
              continue;
            }
            
            // Calculate velocity in pixels per second
            const dx = current.x - prev.x;
            const dy = current.y - prev.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            const velocity = distance / dt;
            
            // Add velocity information to the data point
            current.velocity = velocity;
            
            // Keep points with velocity below threshold (not a saccade)
            if (velocity < settings.velocityThreshold) {
              velocityFiltered.push(current);
            }
          }
          
          filteredData = velocityFiltered;
        }
        
        // Step 4: Apply exponential smoothing
        if (filteredData.length > 1) {
          const smoothed = [filteredData[0]]; // Keep first point unchanged
          
          for (let i = 1; i < filteredData.length; i++) {
            const current = { ...filteredData[i] };
            const prev = smoothed[i-1];
            
            // Apply exponential smoothing formula: y_smooth = α * y_current + (1-α) * y_prev
            current.x = settings.smoothingFactor * current.x + (1 - settings.smoothingFactor) * prev.x;
            current.y = settings.smoothingFactor * current.y + (1 - settings.smoothingFactor) * prev.y;
            
            smoothed.push(current);
          }
          
          filteredData = smoothed;
        }
        
        // Step 5: Add derived metrics for analysis
        for (let i = 1; i < filteredData.length; i++) {
          const current = filteredData[i];
          const prev = filteredData[i-1];
          
          // Calculate gaze displacement
          const dx = current.x - prev.x;
          const dy = current.y - prev.y;
          const displacement = Math.sqrt(dx*dx + dy*dy);
          
          // Time difference in ms
          const timeDiff = current.timestamp - prev.timestamp;
          
          // Add derived metrics
          current.displacement = displacement;
          current.timeDelta = timeDiff;
          current.velocity = current.velocity || (timeDiff > 0 ? (displacement / timeDiff) * 1000 : 0);
        }
        
        return filteredData;
      }

      // Helper function to calculate median
      function calculateMedian(values) {
        if (!values || values.length === 0) return 0;
        
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        
        if (sorted.length % 2 === 0) {
          return (sorted[mid - 1] + sorted[mid]) / 2;
        } else {
          return sorted[mid];
        }
      }

      // Advanced eye movement detection and classification
      function detectEyeMovements(gazeData, options = {}) {
        if (!gazeData || gazeData.length < 3) {
          return { fixations: [], saccades: [], smoothPursuits: [], blinks: [] };
        }
        
        // Default parameters for eye movement detection
        const defaults = {
          fixationMinDuration: 100, // ms
          fixationDispersionThreshold: 30, // pixels
          saccadeVelocityThreshold: 300, // pixels/second
          blinkDetectionEnabled: true,
          pursuitDetectionEnabled: true,
          pursuitVelocityRange: [30, 150], // pixels/second
          pursuitDirectionChangeMax: 45, // degrees
          blinkMaxGapDuration: 400 // ms
        };
        
        const settings = { ...defaults, ...options };
        
        // Filter and prepare the data
        const data = filterGazeData(gazeData, {
          outlierThreshold: 3.0,
          smoothingFactor: 0.1
        });
        
        if (data.length < 3) {
          return { fixations: [], saccades: [], smoothPursuits: [], blinks: [] };
        }
        
        // 1. Identify blinks (data gaps)
        const blinks = [];
        const nonBlinkData = [];
        let lastTimestamp = data[0].timestamp;
        
        // First detect blinks (missing data or large gaps)
        if (settings.blinkDetectionEnabled) {
          for (let i = 0; i < data.length; i++) {
            const point = data[i];
            
            // Check for missing data points indicating potential blinks
            if (i > 0) {
              const gap = point.timestamp - lastTimestamp;
              
              // Large gap could indicate a blink
              if (gap > settings.blinkMaxGapDuration) {
                blinks.push({
                  startTime: lastTimestamp,
                  endTime: point.timestamp,
                  duration: gap
                });
                
                // Skip this point from further analysis
                lastTimestamp = point.timestamp;
                continue;
              }
            }
            
            lastTimestamp = point.timestamp;
            nonBlinkData.push(point);
          }
        } else {
          // If blink detection disabled, use all data
          nonBlinkData.push(...data);
        }
        
        // 2. Algorithm: Velocity-Based Detection with Adaptive Thresholds
        const events = [];
        const velocities = nonBlinkData.map(d => d.velocity || 0);
        
        // Calculate stats for adaptive thresholding
        const medianVelocity = calculateMedian(velocities);
        const highVelocities = velocities.filter(v => v > medianVelocity);
        const lowVelocities = velocities.filter(v => v <= medianVelocity);
        
        // Adaptive thresholds based on data
        const adaptiveSaccadeThreshold = settings.saccadeVelocityThreshold;
        const adaptiveFixationThreshold = Math.min(
          settings.fixationDispersionThreshold,
          calculateMedian(lowVelocities) * 3
        );
        
        // Analyze data points
        let currentEvent = {
          type: 'unknown',
          startIndex: 0,
          points: [nonBlinkData[0]],
          velocities: [nonBlinkData[0].velocity || 0]
        };
        
        for (let i = 1; i < nonBlinkData.length; i++) {
          const point = nonBlinkData[i];
          const velocity = point.velocity || 0;
          
          // Decision logic for event classification
          if (velocity > adaptiveSaccadeThreshold) {
            // High velocity indicates a saccade
            if (currentEvent.type !== 'saccade') {
              // End the previous event and start a new saccade
              if (currentEvent.points.length > 0) {
                finishEvent(currentEvent);
                events.push(currentEvent);
              }
              
              currentEvent = {
                type: 'saccade',
                startIndex: i,
                points: [point],
                velocities: [velocity]
              };
            } else {
              // Continue the current saccade
              currentEvent.points.push(point);
              currentEvent.velocities.push(velocity);
            }
          } else if (velocity < adaptiveFixationThreshold) {
            // Low velocity indicates a fixation
            
            // Check spatial dispersion for fixation
            let isWithinFixationThreshold = true;
            if (currentEvent.type === 'fixation' && currentEvent.points.length > 0) {
              const centroidX = currentEvent.centroidX;
              const centroidY = currentEvent.centroidY;
              const distance = Math.sqrt(
                Math.pow(point.x - centroidX, 2) +
                Math.pow(point.y - centroidY, 2)
              );
              
              isWithinFixationThreshold = distance < settings.fixationDispersionThreshold;
            }
            
            if (currentEvent.type !== 'fixation' || !isWithinFixationThreshold) {
              // End the previous event and start a new fixation
              if (currentEvent.points.length > 0) {
                finishEvent(currentEvent);
                events.push(currentEvent);
              }
              
              // Initialize centroid with first point
              currentEvent = {
                type: 'fixation',
                startIndex: i,
                points: [point],
                velocities: [velocity],
                centroidX: point.x,
                centroidY: point.y
              };
            } else {
              // Update the current fixation
              currentEvent.points.push(point);
              currentEvent.velocities.push(velocity);
              
              // Recalculate centroid with new point
              const n = currentEvent.points.length;
              currentEvent.centroidX = (currentEvent.centroidX * (n-1) + point.x) / n;
              currentEvent.centroidY = (currentEvent.centroidY * (n-1) + point.y) / n;
            }
          } else {
            // Medium velocity could be smooth pursuit
            if (settings.pursuitDetectionEnabled) {
              // Check if velocity is in pursuit range
              const isPursuit = velocity >= settings.pursuitVelocityRange[0] && 
                              velocity <= settings.pursuitVelocityRange[1];
              
              // Check direction consistency for pursuit
              let isDirectionConsistent = true;
              if (currentEvent.type === 'smooth_pursuit' && currentEvent.points.length > 1) {
                const prevPoint = currentEvent.points[currentEvent.points.length - 1];
                const prevPrevPoint = currentEvent.points[currentEvent.points.length - 2];
                
                // Calculate direction vectors
                const dir1 = {
                  x: prevPoint.x - prevPrevPoint.x,
                  y: prevPoint.y - prevPrevPoint.y
                };
                
                const dir2 = {
                  x: point.x - prevPoint.x,
                  y: point.y - prevPoint.y
                };
                
                // Calculate angle between vectors
                const dot = dir1.x * dir2.x + dir1.y * dir2.y;
                const mag1 = Math.sqrt(dir1.x * dir1.x + dir1.y * dir1.y);
                const mag2 = Math.sqrt(dir2.x * dir2.x + dir2.y * dir2.y);
                
                if (mag1 > 0 && mag2 > 0) {
                  const cosAngle = dot / (mag1 * mag2);
                  const angleRad = Math.acos(Math.min(Math.max(cosAngle, -1), 1));
                  const angleDeg = angleRad * (180 / Math.PI);
                  
                  isDirectionConsistent = angleDeg < settings.pursuitDirectionChangeMax;
                }
              }
              
              if (isPursuit && (currentEvent.type === 'smooth_pursuit' && isDirectionConsistent)) {
                // Continue the current smooth pursuit
                currentEvent.points.push(point);
                currentEvent.velocities.push(velocity);
              } else if (isPursuit) {
                // End the previous event and start a new smooth pursuit
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                currentEvent = {
                  type: 'smooth_pursuit',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity]
                };
              } else {
                // Not a pursuit, treat as saccade or fixation based on velocity
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                // Default to fixation if in doubt
                currentEvent = {
                  type: 'fixation',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity],
                  centroidX: point.x,
                  centroidY: point.y
                };
              }
            } else {
              // If pursuit detection disabled, classify as fixation
              if (currentEvent.type !== 'fixation') {
                // End the previous event and start a new fixation
                if (currentEvent.points.length > 0) {
                  finishEvent(currentEvent);
                  events.push(currentEvent);
                }
                
                currentEvent = {
                  type: 'fixation',
                  startIndex: i,
                  points: [point],
                  velocities: [velocity],
                  centroidX: point.x,
                  centroidY: point.y
                };
              } else {
                // Update the current fixation
                currentEvent.points.push(point);
                currentEvent.velocities.push(velocity);
                
                // Recalculate centroid
                const n = currentEvent.points.length;
                currentEvent.centroidX = (currentEvent.centroidX * (n-1) + point.x) / n;
                currentEvent.centroidY = (currentEvent.centroidY * (n-1) + point.y) / n;
              }
            }
          }
        }
        
        // Add the final event
        if (currentEvent.points.length > 0) {
          finishEvent(currentEvent);
          events.push(currentEvent);
        }
        
        // Extract events by type
        const fixations = events
          .filter(e => e.type === 'fixation' && e.duration >= settings.fixationMinDuration)
          .map(processFurtherFixation);
          
        const saccades = events
          .filter(e => e.type === 'saccade')
          .map(processFurtherSaccade);
          
        const smoothPursuits = events
          .filter(e => e.type === 'smooth_pursuit')
          .map(processFurtherPursuit);
        
        return {
          fixations,
          saccades,
          smoothPursuits,
          blinks
        };
        
        // Helper to finish processing an event
        function finishEvent(event) {
          if (event.points.length < 2) return;
          
          const startTime = event.points[0].timestamp;
          const endTime = event.points[event.points.length - 1].timestamp;
          
          event.startTime = startTime;
          event.endTime = endTime;
          event.duration = endTime - startTime;
          
          // Calculate average velocity
          event.avgVelocity = event.velocities.reduce((sum, v) => sum + v, 0) / event.velocities.length;
          
          // For fixations, refine centroid and calculate dispersion
          if (event.type === 'fixation') {
            // Calculate all x and y coordinates
            const xValues = event.points.map(p => p.x);
            const yValues = event.points.map(p => p.y);
            
            // Calculate dispersion as max distance from center
            const dispX = Math.max(...xValues) - Math.min(...xValues);
            const dispY = Math.max(...yValues) - Math.min(...yValues);
            event.dispersion = Math.max(dispX, dispY);
            
            // Store the positions for this fixation
            event.x = event.centroidX;
            event.y = event.centroidY;
          }
          
          // For saccades, calculate amplitude and direction
          if (event.type === 'saccade') {
            const startX = event.points[0].x;
            const startY = event.points[0].y;
            const endX = event.points[event.points.length - 1].x;
            const endY = event.points[event.points.length - 1].y;
            
            event.startX = startX;
            event.startY = startY;
            event.endX = endX;
            event.endY = endY;
            
            // Calculate amplitude (distance)
            event.amplitude = Math.sqrt(
              Math.pow(endX - startX, 2) + 
              Math.pow(endY - startY, 2)
            );
            
            // Calculate direction in degrees (0=right, 90=up, 180=left, 270=down)
            event.direction = (Math.atan2(endY - startY, endX - startX) * 180 / Math.PI + 360) % 360;
            
            // Peak velocity
            event.peakVelocity = Math.max(...event.velocities);
          }
          
          // For smooth pursuits, calculate path and direction
          if (event.type === 'smooth_pursuit') {
            const startX = event.points[0].x;
            const startY = event.points[0].y;
            const endX = event.points[event.points.length - 1].x;
            const endY = event.points[event.points.length - 1].y;
            
            event.startX = startX;
            event.startY = startY;
            event.endX = endX;
            event.endY = endY;
            
            // Calculate path length (sum of all point-to-point distances)
            let pathLength = 0;
            for (let i = 1; i < event.points.length; i++) {
              const dx = event.points[i].x - event.points[i-1].x;
              const dy = event.points[i].y - event.points[i-1].y;
              pathLength += Math.sqrt(dx*dx + dy*dy);
            }
            event.pathLength = pathLength;
            
            // Calculate straightness (direct distance / path length)
            const directDistance = Math.sqrt(
              Math.pow(endX - startX, 2) + 
              Math.pow(endY - startY, 2)
            );
            event.straightness = directDistance / (pathLength || 1); // Avoid division by zero
            
            // Average direction
            event.direction = (Math.atan2(endY - startY, endX - startX) * 180 / Math.PI + 360) % 360;
          }
        }
        
        // Further processing for fixations
        function processFurtherFixation(fixation) {
          // Add additional metrics for fixations
          
          // Calculate temporal precision (stability over time)
          const timePoints = fixation.points.map(p => p.timestamp);
          const timeDiffs = [];
          for (let i = 1; i < timePoints.length; i++) {
            timeDiffs.push(timePoints[i] - timePoints[i-1]);
          }
          
          fixation.temporalPrecision = timeDiffs.length > 0 ? 
            calculateMedian(timeDiffs) : 0;
          
          return fixation;
        }
        
        // Further processing for saccades
        function processFurtherSaccade(saccade) {
          // Additional metrics for saccades
          
          // Calculate main sequence relationship (peak velocity / amplitude)
          saccade.mainSequence = saccade.peakVelocity / (saccade.amplitude || 1);
          
          // Calculate acceleration phase
          const halfIdx = Math.floor(saccade.velocities.length / 2);
          saccade.accelerationPhase = saccade.velocities.slice(0, halfIdx);
          saccade.decelerationPhase = saccade.velocities.slice(halfIdx);
          
          return saccade;
        }
        
        // Further processing for smooth pursuits
        function processFurtherPursuit(pursuit) {
          // Additional metrics for smooth pursuits
          
          // Calculate velocity stability (standard deviation of velocity)
          const velocityMean = pursuit.avgVelocity;
          const velocityVariance = pursuit.velocities.reduce(
            (sum, v) => sum + Math.pow(v - velocityMean, 2), 0
          ) / pursuit.velocities.length;
          
          pursuit.velocityStability = Math.sqrt(velocityVariance) / velocityMean;
          
          return pursuit;
        }
      }

      // Enhanced gaze analysis functions
      function analyzeGaze(gazeData, options = {}) {
        if (!gazeData || gazeData.length < 3) {
          return { success: false, message: "Insufficient gaze data for analysis" };
        }
        
        // Detect eye movements
        const eyeMovements = detectEyeMovements(gazeData, options);
        
        // Extract fixations and saccades
        const { fixations, saccades, smoothPursuits, blinks } = eyeMovements;
        
        // Screen dimensions
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        // Aggregated metrics
        const metrics = {
          // Basic count stats
          totalSamples: gazeData.length,
          trackingRate: calculateTrackingRate(gazeData),
          
          // Fixation metrics
          fixationCount: fixations.length,
          averageFixationDuration: fixations.length > 0 ? 
            fixations.reduce((sum, f) => sum + f.duration, 0) / fixations.length : 0,
          totalFixationTime: fixations.reduce((sum, f) => sum + f.duration, 0),
          
          // Saccade metrics
          saccadeCount: saccades.length,
          averageSaccadeAmplitude: saccades.length > 0 ?
            saccades.reduce((sum, s) => sum + s.amplitude, 0) / saccades.length : 0,
          averageSaccadeVelocity: saccades.length > 0 ?
            saccades.reduce((sum, s) => sum + s.avgVelocity, 0) / saccades.length : 0,
          
          // Pursuit metrics
          pursuitCount: smoothPursuits.length,
          averagePursuitDuration: smoothPursuits.length > 0 ?
            smoothPursuits.reduce((sum, p) => sum + p.duration, 0) / smoothPursuits.length : 0,
          
          // Blink metrics
          blinkCount: blinks.length,
          blinkRate: blinks.length / (gazeData[gazeData.length - 1].timestamp - gazeData[0].timestamp) * 60000, // blinks per minute
          
          // Coverage metrics
          spatialDensity: calculateSpatialDensity(fixations, screenWidth, screenHeight),
          
          // Define regions of interest (example: divide screen into 9 regions)
          regionAnalysis: analyzeRegionsOfInterest(fixations, {
            regions: defineRegions(screenWidth, screenHeight)
          }),
          
          // Scanpath metrics
          scanpathLength: calculateScanpathLength(fixations),
          scanpathArea: calculateConvexHullArea(fixations),
          
          // Transitional metrics
          transitionMatrix: calculateTransitionMatrix(fixations, {
            regions: defineRegions(screenWidth, screenHeight)
          })
        };
        
        return {
          success: true,
          metrics,
          eyeMovements,
          regions: defineRegions(screenWidth, screenHeight)
        };
        
        // Helper function to calculate tracking rate
        function calculateTrackingRate(data) {
          if (data.length < 2) return 0;
          
          const duration = data[data.length - 1].timestamp - data[0].timestamp;
          return (data.length / duration) * 1000; // samples per second
        }
        
        // Helper function to define regions of interest
        function defineRegions(width, height, rows = 3, cols = 3) {
          const regions = [];
          const cellWidth = width / cols;
          const cellHeight = height / rows;
          
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              regions.push({
                id: row * cols + col,
                name: `R${row * cols + col + 1}`,
                x: col * cellWidth,
                y: row * cellHeight,
                width: cellWidth,
                height: cellHeight
              });
            }
          }
          
          return regions;
        }
        
        // Helper function to analyze fixations in regions of interest
        function analyzeRegionsOfInterest(fixations, { regions }) {
          // Count fixations in each region
          const regionCounts = Array(regions.length).fill(0);
          const regionDurations = Array(regions.length).fill(0);
          
          fixations.forEach(fixation => {
            const regionIndex = getRegionIndex(fixation.x, fixation.y, regions);
            if (regionIndex >= 0) {
              regionCounts[regionIndex]++;
              regionDurations[regionIndex] += fixation.duration;
            }
          });
          
          // Calculate aggregated metrics for each region
          return regions.map((region, index) => ({
            regionId: region.id,
            regionName: region.name,
            fixationCount: regionCounts[index],
            fixationPercentage: fixations.length > 0 ? 
              (regionCounts[index] / fixations.length) * 100 : 0,
            totalFixationTime: regionDurations[index],
            fixationTimePercentage: regionDurations.reduce((sum, d) => sum + d, 0) > 0 ?
              (regionDurations[index] / regionDurations.reduce((sum, d) => sum + d, 0)) * 100 : 0
          }));
        }
        
        // Helper function to get region index for a point
        function getRegionIndex(x, y, regions) {
          for (let i = 0; i < regions.length; i++) {
            const region = regions[i];
            if (x >= region.x && x < region.x + region.width &&
                y >= region.y && y < region.y + region.height) {
              return i;
            }
          }
          return -1; // Point is outside all regions
        }
        
        // Helper function to calculate spatial density
        function calculateSpatialDensity(fixations, screenWidth, screenHeight) {
          if (fixations.length === 0) return 0;
          
          // Create a grid over the screen
          const gridSize = 10; // 10x10 grid
          const cellWidth = screenWidth / gridSize;
          const cellHeight = screenHeight / gridSize;
          
          // Count occupied cells
          const occupiedCells = new Set();
          
          fixations.forEach(fixation => {
            const gridX = Math.floor(fixation.x / cellWidth);
            const gridY = Math.floor(fixation.y / cellHeight);
            occupiedCells.add(`${gridX},${gridY}`);
          });
          
          // Return percentage of grid cells that received at least one fixation
          return (occupiedCells.size / (gridSize * gridSize)) * 100;
        }
        
        // Helper function to calculate scanpath length
        function calculateScanpathLength(fixations) {
          if (fixations.length < 2) return 0;
          
          let length = 0;
          for (let i = 1; i < fixations.length; i++) {
            const dx = fixations[i].x - fixations[i-1].x;
            const dy = fixations[i].y - fixations[i-1].y;
            length += Math.sqrt(dx*dx + dy*dy);
          }
          
          return length;
        }
        
        // Helper function to calculate convex hull area of fixations
        function calculateConvexHullArea(fixations) {
          if (fixations.length < 3) return 0;
          
          // Extract points
          const points = fixations.map(f => ({ x: f.x, y: f.y }));
          
          // Compute convex hull (Gift wrapping algorithm)
          const hull = computeConvexHull(points);
          
          // Calculate area of polygon
          return calculatePolygonArea(hull);
          
          // Gift wrapping algorithm for convex hull
          function computeConvexHull(points) {
            if (points.length < 3) return points;
            
            // Find leftmost point
            let leftmost = 0;
            for (let i = 1; i < points.length; i++) {
              if (points[i].x < points[leftmost].x) {
                leftmost = i;
              }
            }
            
            const hull = [];
            let p = leftmost;
            
            do {
              hull.push(points[p]);
              
              let q = (p + 1) % points.length;
              for (let i = 0; i < points.length; i++) {
                if (orientation(points[p], points[i], points[q]) === 2) {
                  q = i;
                }
              }
              
              p = q;
            } while (p !== leftmost);
            
            return hull;
          }
          
          // Calculate orientation of triplet (p, q, r)
          function orientation(p, q, r) {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0; // collinear
            return (val > 0) ? 1 : 2; // clockwise or counterclockwise
          }
          
          // Calculate area of polygon using Shoelace formula
          function calculatePolygonArea(vertices) {
            let area = 0;
            const n = vertices.length;
            
            for (let i = 0; i < n; i++) {
              const j = (i + 1) % n;
              area += vertices[i].x * vertices[j].y;
              area -= vertices[j].x * vertices[i].y;
            }
            
            return Math.abs(area) / 2;
          }
        }
        
        // Helper function to calculate transition matrix between regions
        function calculateTransitionMatrix(fixations, { regions }) {
          if (fixations.length < 2) return [];
          
          // Initialize transition matrix with zeros
          const n = regions.length;
          const matrix = Array(n).fill().map(() => Array(n).fill(0));
          
          // Count transitions between regions
          for (let i = 1; i < fixations.length; i++) {
            const fromRegion = getRegionIndex(fixations[i-1].x, fixations[i-1].y, regions);
            const toRegion = getRegionIndex(fixations[i].x, fixations[i].y, regions);
            
            if (fromRegion >= 0 && toRegion >= 0) {
              matrix[fromRegion][toRegion]++;
            }
          }
          
          return matrix;
        }
      }

      // Initialize coordinate plane for screen
      function initCoordinatePlane() {
        coordinatePlane = document.createElement('div');
        coordinatePlane.id = 'coordinatePlane';
        coordinatePlane.style.position = 'absolute';
        coordinatePlane.style.top = '0';
        coordinatePlane.style.left = '0';
        coordinatePlane.style.width = '100%';
        coordinatePlane.style.height = '100%';
        coordinatePlane.style.pointerEvents = 'none';
        coordinatePlane.style.zIndex = '1000';
        document.body.appendChild(coordinatePlane);
        
        // Create canvas for coordinate plane
        const canvas = document.createElement('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        coordinatePlane.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = config.coordinatePlaneColor;
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        
        // Add coordinate labels
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = x;
          label.style.position = 'absolute';
          label.style.left = `${x}px`;
          label.style.top = '5px';
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = y;
          label.style.position = 'absolute';
          label.style.left = '5px';
          label.style.top = `${y}px`;
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        return coordinatePlane;
      }
      
      // Initialize heatmap layer
      function initHeatmap() {
        if (heatmapLayer) {
          document.body.removeChild(heatmapLayer);
        }
        
        heatmapLayer = document.createElement('canvas');
        heatmapLayer.id = 'heatmapLayer';
        heatmapLayer.width = window.innerWidth;
        heatmapLayer.height = window.innerHeight;
        heatmapLayer.style.position = 'absolute';
        heatmapLayer.style.top = '0';
        heatmapLayer.style.left = '0';
        heatmapLayer.style.pointerEvents = 'none';
        heatmapLayer.style.opacity = config.heatmapOpacity;
        heatmapLayer.style.zIndex = '999';
        document.body.appendChild(heatmapLayer);
        
        return heatmapLayer;
      }
      
      // Update heatmap based on gaze history
      function updateHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure (simple 2D grid)
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Populate grid with gaze data
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            heatGrid[gridY][gridX] += 1;
          }
        });
        
        // Find maximum value for normalization
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        // Draw heatmap
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Head position and tilt calibration
      async function calibrateHeadPosition() {
        ui.statusText.textContent = 'Head Position Calibration...';
        updateProgress(0);
        
        // Create visual guide for head position
        const headGuide = document.createElement('div');
        headGuide.style.position = 'absolute';
        headGuide.style.top = '50%';
        headGuide.style.left = '50%';
        headGuide.style.transform = 'translate(-50%, -50%)';
        headGuide.style.width = '300px';
        headGuide.style.height = '300px';
        headGuide.style.border = '2px dashed white';
        headGuide.style.borderRadius = '50%';
        headGuide.style.zIndex = '1001';
        document.body.appendChild(headGuide);
        
        // Text instructions
        const instructions = document.createElement('div');
        instructions.textContent = 'Position your head in the center and remain still';
        instructions.style.position = 'absolute';
        instructions.style.top = 'calc(50% + 170px)';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.color = 'white';
        instructions.style.fontSize = '18px';
        instructions.style.fontWeight = 'bold';
        instructions.style.zIndex = '1002';
        document.body.appendChild(instructions);
        
        // Collect head position samples
        const samples = [];
        for (let i = 0; i < config.headCalibrationSamples; i++) {
          updateProgress((i / config.headCalibrationSamples) * 100);
          
          // Get current face position from WebGazer
          const currentFace = await new Promise(resolve => {
            webgazer.getCurrentFaceFeatures().then(features => {
              resolve(features);
            });
          });
          
          if (currentFace) {
            samples.push(currentFace);
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Calculate average head position and orientation
        if (samples.length > 0) {
          headCalibrationData = {
            timestamp: Date.now(),
            samples: samples,
            averagePosition: calculateAverageHeadPosition(samples)
          };
          
          showNotification('Head position calibrated successfully');
        } else {
          showNotification('Head calibration failed. Please try again.', true);
        }
        
        // Clean up
        document.body.removeChild(headGuide);
        document.body.removeChild(instructions);
        
        return samples.length > 0;
      }
      
      // Calculate average head position from samples
      function calculateAverageHeadPosition(samples) {
        if (!samples || samples.length === 0) return null;
        
        // Extract comprehensive face metrics for more accurate head position tracking
        const avgPosition = { 
          x: 0, 
          y: 0, 
          width: 0, 
          height: 0,
          rotation: 0,
          confidence: 0,
          eyeDistance: 0,
          faceCenter: { x: 0, y: 0 }
        };
        
        // Count valid samples for accurate averaging
        let validSamples = 0;
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            // Basic position metrics
            avgPosition.x += sample.imagex;
            avgPosition.y += sample.imagey;
            avgPosition.width += sample.width;
            avgPosition.height += sample.height;
            
            // Advanced metrics if available
            if (sample.rotation !== undefined) {
              avgPosition.rotation += sample.rotation;
            }
            
            if (sample.confidence !== undefined) {
              avgPosition.confidence += sample.confidence;
            }
            
            // Calculate eye distance if eye positions are available
            if (sample.eyeLeft && sample.eyeRight) {
              const distance = Math.sqrt(
                Math.pow(sample.eyeRight.x - sample.eyeLeft.x, 2) + 
                Math.pow(sample.eyeRight.y - sample.eyeLeft.y, 2)
              );
              avgPosition.eyeDistance += distance;
              
              // Calculate face center based on eye positions
              avgPosition.faceCenter.x += (sample.eyeLeft.x + sample.eyeRight.x) / 2;
              avgPosition.faceCenter.y += (sample.eyeLeft.y + sample.eyeRight.y) / 2;
            }
            
            validSamples++;
          }
        });
        
        // Use valid sample count for averaging to handle missing data
        const sampleCount = validSamples || 1; // Prevent division by zero
        
        avgPosition.x /= sampleCount;
        avgPosition.y /= sampleCount;
        avgPosition.width /= sampleCount;
        avgPosition.height /= sampleCount;
        avgPosition.rotation /= sampleCount;
        avgPosition.confidence /= sampleCount;
        avgPosition.eyeDistance /= sampleCount;
        avgPosition.faceCenter.x /= sampleCount;
        avgPosition.faceCenter.y /= sampleCount;
        
        // Calculate standard deviation for position stability assessment
        avgPosition.stability = calculatePositionStability(samples, avgPosition);
        
        return avgPosition;
      }
      
      // Helper function to calculate position stability
      function calculatePositionStability(samples, avgPosition) {
        if (!samples || samples.length < 2) return 1.0;
        
        let varianceSum = 0;
        let validSamples = 0;
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            const xDiff = sample.imagex - avgPosition.x;
            const yDiff = sample.imagey - avgPosition.y;
            varianceSum += (xDiff * xDiff) + (yDiff * yDiff);
            validSamples++;
          }
        });
        
        const variance = varianceSum / (validSamples || 1);
        const stdDev = Math.sqrt(variance);
        
        // Convert to stability score (0-1 range, higher is more stable)
        const maxExpectedDeviation = 50; // Pixels
        return Math.max(0, Math.min(1, 1 - (stdDev / maxExpectedDeviation)));
      }
      
      // Start recording session
      async function startRecordingSession() {
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        recordingStartTime = Date.now();
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object
        recordingSession = {
          id: `session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        // Start recording loop
        ui.statusText.textContent = 'Recording in progress...';
        isExperimentRunning = true;
        
        const recordingLoop = async () => {
          if (!isExperimentRunning) return;
          
          const elapsedTime = (Date.now() - recordingStartTime) / 1000;
          updateProgress((elapsedTime / config.recordingDuration) * 100);
          
          // Get current gaze prediction
          const prediction = await webgazer.getCurrentPrediction();
          if (prediction) {
            // Add to history for heatmap
            gazeHistory.push({
              x: prediction.x,
              y: prediction.y,
              timestamp: Date.now() - recordingStartTime
            });
            
            // Add to recording data
            recordingSession.frames.push({
              timestamp: Date.now() - recordingStartTime,
              gazeX: prediction.x,
              gazeY: prediction.y,
              headPosition: await webgazer.getCurrentFaceFeatures()
            });
            
            // Draw current gaze point
            drawGazePoint(prediction.x, prediction.y);
            
            // Update heatmap if enabled
            if (heatmapEnabled) {
              updateHeatmap();
            }
          }
          
          // Check if recording duration has been reached
          if (elapsedTime >= config.recordingDuration) {
            stopRecordingSession();
            showNotification('Recording completed');
            ui.exportContainer.style.display = 'flex';
          } else {
            // Continue loop
            requestAnimationFrame(recordingLoop);
          }
        };
        
        // Start the recording loop
        recordingLoop();
        
        return true;
      }
      
      // Stop recording session
      function stopRecordingSession() {
        isExperimentRunning = false;
        
        if (recordingSession) {
          recordingSession.endTime = Date.now();
          recordingSession.duration = recordingSession.endTime - recordingSession.startTime;
          
          // Save recording data
          gazeData = recordingSession.frames;
          
          // Clean up
          if (coordinatePlane) {
            document.body.removeChild(coordinatePlane);
            coordinatePlane = null;
          }
          
          if (heatmapLayer) {
            document.body.removeChild(heatmapLayer);
            heatmapLayer = null;
          }
          
          ui.statusText.textContent = 'Recording stopped';
          updateProgress(100);
          
          // Stop auto-save interval if running
          if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
          }
          
          // Stop inactivity timer if running
          if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
          }
        }
      }
      
      // Draw current gaze point
      function drawGazePoint(x, y) {
        // Remove previous gaze point if exists
        const existingPoint = document.getElementById('currentGazePoint');
        if (existingPoint) {
          document.body.removeChild(existingPoint);
        }
        
        // Create new gaze point
        const gazePoint = document.createElement('div');
        gazePoint.id = 'currentGazePoint';
        gazePoint.style.position = 'absolute';
        gazePoint.style.top = `${y}px`;
        gazePoint.style.left = `${x}px`;
        gazePoint.style.width = '20px';
        gazePoint.style.height = '20px';
        gazePoint.style.borderRadius = '50%';
        gazePoint.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        gazePoint.style.transform = 'translate(-50%, -50%)';
        gazePoint.style.zIndex = '1003';
        gazePoint.style.pointerEvents = 'none';
        document.body.appendChild(gazePoint);
        
        // Add ripple effect
        const ripple = document.createElement('div');
        ripple.style.position = 'absolute';
        ripple.style.top = '50%';
        ripple.style.left = '50%';
        ripple.style.width = '100%';
        ripple.style.height = '100%';
        ripple.style.borderRadius = '50%';
        ripple.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        ripple.style.transform = 'translate(-50%, -50%) scale(1)';
        ripple.style.transition = 'all 0.5s ease-out';
        gazePoint.appendChild(ripple);
        
        setTimeout(() => {
          ripple.style.transform = 'translate(-50%, -50%) scale(2)';
          ripple.style.opacity = '0';
        }, 10);
      }
      
      // Toggle heatmap visibility
      function toggleHeatmap() {
        heatmapEnabled = !heatmapEnabled;
        
        if (heatmapEnabled) {
          if (!heatmapLayer) {
            initHeatmap();
          }
          updateHeatmap();
          showNotification('Heatmap enabled');
        } else {
          if (heatmapLayer) {
            const ctx = heatmapLayer.getContext('2d');
            ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
          }
          showNotification('Heatmap disabled');
        }
      }
      
      // Export recording data
      function exportRecordingData() {
        console.log('Starting export of recording data...');
        
        if (!recordingSession || recordingSession.frames.length === 0) {
          console.error('Export failed: No recording data available');
          showNotification('No recording data available', true);
          return;
        }
        
        console.log(`Preparing to export ${recordingSession.frames.length} frames of data`);
        
        try {
          // Prepare CSV data
          console.log('Generating CSV content...');
          const csvContent = "data:text/csv;charset=utf-8," + 
            "timestamp,gazeX,gazeY,headX,headY,headWidth,headHeight\n" +
            recordingSession.frames.map(frame => {
              const head = frame.headPosition || {};
              return `${frame.timestamp},${frame.gazeX},${frame.gazeY},` +
                     `${head.imagex || ''},${head.imagey || ''},` +
                     `${head.width || ''},${head.height || ''}`;
            }).join("\n");
          
          console.log('CSV content generated successfully');
          
          // Create download link
          const csvLink = document.createElement('a');
          csvLink.href = encodeURI(csvContent);
          csvLink.download = `gaze_recording_${recordingSession.id}.csv`;
          console.log(`Initiating CSV download: gaze_recording_${recordingSession.id}.csv`);
          csvLink.click();
          
          // Prepare JSON data
          console.log('Generating JSON content...');
          const jsonData = {
            sessionInfo: {
              id: recordingSession.id,
              startTime: recordingSession.startTime,
              endTime: recordingSession.endTime,
              duration: recordingSession.duration,
              screenDimensions: recordingSession.screenDimensions
            },
            headCalibration: recordingSession.headCalibration,
            frames: recordingSession.frames
          };
          
          console.log('JSON object created with session metadata');
          
          const jsonContent = "data:text/json;charset=utf-8," + 
            encodeURIComponent(JSON.stringify(jsonData));
          
          // Create download link
          const jsonLink = document.createElement('a');
          jsonLink.href = jsonContent;
          jsonLink.download = `gaze_recording_${recordingSession.id}.json`;
          console.log(`Initiating JSON download: gaze_recording_${recordingSession.id}.json`);
          jsonLink.click();
          
          console.log('Export completed successfully');
          showNotification('Recording data exported');
        } catch (error) {
          console.error('Export failed with error:', error);
          showNotification('Export failed: ' + error.message, true);
        }
      }

      // Run a single trial
      async function runTrial(trialNumber) {
        console.log(`Starting trial ${trialNumber}...`);
        currentTrial = trialNumber;
        
        try {
          // Show fixation cross
          console.log('Displaying fixation cross');
          const fixation = new psychoJS.visual.TextStim({
            win: experimentWindow,
            text: '+',
            height: 0.1,
            color: new psychoJS.Color('white')
          });

          fixation.draw();
          experimentWindow.flip();
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Show stimulus
          console.log(`Displaying stimulus for trial ${trialNumber}`);
          const stimulus = new psychoJS.visual.TextStim({
            win: experimentWindow,
            text: `Trial ${trialNumber}`,
            height: 0.1,
            color: new psychoJS.Color('white')
          });

          stimulus.draw();
          experimentWindow.flip();
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          // Inter-trial interval
          console.log('Inter-trial interval');
          experimentWindow.flip();
          await new Promise(resolve => setTimeout(resolve, 500));
          
          console.log(`Trial ${trialNumber} completed successfully`);
        } catch (error) {
          console.error(`Error in trial ${trialNumber}:`, error);
          showNotification(`Trial error: ${error.message}`, true);
        }
      }
      
      // Export data
      function exportData() {
        console.log('Starting export of experiment data...');
        
        if (!gazeData || gazeData.length === 0) {
          console.error('Export failed: No gaze data available');
          showNotification('No data available to export', true);
          return;
        }
        
        console.log(`Preparing to export ${gazeData.length} gaze data points`);
        
        try {
          // CSV Export
          console.log('Generating CSV content...');
          const csvContent = "data:text/csv;charset=utf-8," + 
            "timestamp,x,y,trial\n" +
            gazeData.map(row => 
              `${row.timestamp},${row.x},${row.y},${row.trial}`
            ).join("\n");

          const csvLink = document.createElement('a');
          csvLink.href = encodeURI(csvContent);
          csvLink.download = 'gaze_data.csv';
          console.log('Initiating CSV download: gaze_data.csv');
          csvLink.click();

          // JSON Export
          console.log('Generating JSON content...');
          const jsonContent = "data:text/json;charset=utf-8," + 
            encodeURIComponent(JSON.stringify(gazeData));

          const jsonLink = document.createElement('a');
          jsonLink.href = jsonContent;
          jsonLink.download = 'gaze_data.json';
          console.log('Initiating JSON download: gaze_data.json');
          jsonLink.click();
          
          console.log('Export completed successfully');
          showNotification('Data exported successfully');
        } catch (error) {
          console.error('Export failed with error:', error);
          showNotification('Export failed: ' + error.message, true);
        }
      }

      // UI Updates
      function updateProgress(percent) {
        console.log(`Updating progress bar to ${percent}%`);
        if (ui && ui.progressBar) {
          ui.progressBar.style.width = `${percent}%`;
        } else {
          console.warn("Progress bar element not found or not yet initialized");
        }
      }

      function showNotification(message, isError = false) {
        console.log(`Notification: ${message}${isError ? ' (ERROR)' : ''}`);
        ui.notification.textContent = message;
        ui.notification.classList.toggle('error', isError);
        ui.notification.classList.add('show');
        setTimeout(() => ui.notification.classList.remove('show'), 3000);
      }

      function resetUI() {
        console.log('Resetting UI elements');
        ui.calibrateBtn.disabled = true;
        ui.abortBtn.disabled = true;
        ui.progressBar.style.width = '0%';
        ui.statusText.textContent = 'Experiment ready';
        ui.exportContainer.style.display = 'none';
      }

      // MODIFY EXISTING UI ELEMENTS AND ADD NEW ONES
      document.addEventListener('DOMContentLoaded', () => {
        // Add new buttons for the second pipeline
        const controls = document.querySelector('.controls');
        
        // Add heatmap toggle button
        const heatmapBtn = document.createElement('button');
        heatmapBtn.id = 'heatmapBtn';
        heatmapBtn.className = 'btn';
        heatmapBtn.type = 'button';
        heatmapBtn.textContent = 'Toggle Heatmap';
        heatmapBtn.disabled = true;
        controls.appendChild(heatmapBtn);
        
        // Add head calibration button
        const headCalibBtn = document.createElement('button');
        headCalibBtn.id = 'headCalibBtn';
        headCalibBtn.className = 'btn';
        headCalibBtn.type = 'button';
        headCalibBtn.textContent = 'Calibrate Head Position';
        headCalibBtn.disabled = true;
        controls.appendChild(headCalibBtn);
        
        // Add recording button
        const recordBtn = document.createElement('button');
        recordBtn.id = 'recordBtn';
        recordBtn.className = 'btn';
        recordBtn.type = 'button';
        recordBtn.textContent = 'Start Recording';
        recordBtn.disabled = true;
        controls.appendChild(recordBtn);
        
        // Update UI object with new elements
        ui.heatmapBtn = heatmapBtn;
        ui.headCalibBtn = headCalibBtn;
        ui.recordBtn = recordBtn;
        ui.longDurationControls = document.getElementById('longDurationControls');
        ui.startLongSessionBtn = document.getElementById('startLongSessionBtn');
        ui.pauseResumeBtn = document.getElementById('pauseResumeBtn');
        ui.settingsBtn = document.getElementById('settingsBtn');
        ui.saveSegmentBtn = document.getElementById('saveSegmentBtn');
        ui.sessionStats = document.getElementById('sessionStats');
        ui.settingsPanel = document.getElementById('settingsPanel');
        ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
        ui.applySettingsBtn = document.getElementById('applySettingsBtn');
        ui.pauseIndicator = document.getElementById('pauseIndicator');
        ui.qualityIndicator = document.getElementById('qualityIndicator');
        ui.exportAllSegments = document.getElementById('exportAllSegments');
        
        // Add event listeners for new buttons
        ui.heatmapBtn.addEventListener('click', toggleHeatmap);
        
        ui.headCalibBtn.addEventListener('click', async () => {
          try {
            const headCalibrationSuccess = await calibrateHeadPosition();
            if (headCalibrationSuccess) {
              ui.recordBtn.disabled = false;
              ui.startLongSessionBtn.disabled = false;
              ui.longDurationControls.style.display = 'flex';
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.recordBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning) {
              stopRecordingSession();
              ui.recordBtn.textContent = 'Start Recording';
            } else {
              const recordingStarted = await startRecordingSession();
              if (recordingStarted) {
                ui.recordBtn.textContent = 'Stop Recording';
                ui.heatmapBtn.disabled = false;
              }
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        // Long duration session event listeners
        ui.startLongSessionBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning) {
              await finishLongDurationSession();
              ui.startLongSessionBtn.textContent = 'Start Long Session';
            } else {
              const sessionStarted = await startLongDurationSession();
              if (sessionStarted) {
                ui.startLongSessionBtn.textContent = 'End Long Session';
                ui.heatmapBtn.disabled = false;
                ui.pauseResumeBtn.disabled = false;
                ui.saveSegmentBtn.disabled = false;
              }
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.pauseResumeBtn.addEventListener('click', () => {
          togglePauseRecording();
        });
        
        ui.settingsBtn.addEventListener('click', () => {
          ui.settingsPanel.style.display = 'block';
          
          // Set current values in the form
          document.getElementById('sessionDurationHours').value = config.longDurationHours;
          document.getElementById('segmentDuration').value = config.segmentDuration / 60;
          document.getElementById('autoSaveInterval').value = config.autoSaveInterval / 60;
          document.getElementById('maxGazePoints').value = config.memoryManagement.maxGazeHistoryPoints;
          document.getElementById('downsamplingFactor').value = config.memoryManagement.sampleDownsamplingFactor;
          document.getElementById('pauseDetectionEnabled').checked = config.pauseDetection.enabled;
          document.getElementById('inactivityThreshold').value = config.pauseDetection.inactivityThreshold;
        });
        
        ui.closeSettingsBtn.addEventListener('click', () => {
          ui.settingsPanel.style.display = 'none';
        });
        
        ui.applySettingsBtn.addEventListener('click', () => {
          applySettings();
        });
        
        ui.saveSegmentBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning && isLongDurationSession) {
              await saveCurrentSegment();
              startNewSegment();
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.exportAllSegments.addEventListener('click', () => {
          exportAllSegments();
        });
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.key === 'h' || e.key === 'H') {
            if (!ui.heatmapBtn.disabled) {
              toggleHeatmap();
            }
          } else if (e.key === 'Escape') {
            if (isExperimentRunning) {
              if (isLongDurationSession) {
                togglePauseRecording();
                showNotification('Recording paused with ESC key');
              } else {
                stopRecordingSession();
                ui.recordBtn.textContent = 'Start Recording';
                showNotification('Recording stopped with ESC key');
              }
            }
          } else if (e.key === 'p' || e.key === 'P') {
            if (isLongDurationSession && isExperimentRunning) {
              togglePauseRecording();
            }
          } else if (e.key === 's' || e.key === 'S') {
            if (isLongDurationSession && isExperimentRunning && !isPaused) {
              saveCurrentSegment();
              startNewSegment();
              showNotification('Segment saved with S key');
            }
          }
        });
      });

      // Event Handlers
      ui.startBtn.addEventListener('click', async () => {
        try {
          ui.statusText.textContent = 'Initializing experiment...';
          updateProgress(0);
          
          // First initialize WebGazer
          const webgazerInitialized = await initializeWebGazer();
          if (!webgazerInitialized) {
            throw new Error("WebGazer initialization failed");
          }
          
          // Then initialize PsychoJS
          const psychojsInitialized = initializePsychoJS();
          if (!psychojsInitialized) {
            throw new Error("PsychoJS initialization failed");
          }

          // Only update UI if both succeeded
          if (webgazerInitialized && psychojsInitialized) {
            updateProgress(100);
            ui.calibrateBtn.disabled = false;
            ui.abortBtn.disabled = false;
            ui.headCalibBtn.disabled = false;
            showNotification('Experiment initialized successfully');
          }
        } catch (error) {
          console.error("Experiment initialization error:", error);
          ui.statusText.textContent = 'Initialization failed. Please refresh and try again.';
          showNotification(error.message, true);
        }
      });

      ui.calibrateBtn.addEventListener('click', async () => {
        try {
          ui.statusText.textContent = 'Calibrating...';
          const calibrationSuccess = await runCalibration();
          
          if (calibrationSuccess) {
            showNotification('Calibration completed successfully');
            isExperimentRunning = true;
            
            // Run trials
            for (let trial = 1; trial <= config.trialCount; trial++) {
              if (!isExperimentRunning) break;
          await runTrial(trial);
              updateProgress(trial / config.trialCount * 100);
            }

            // Show export options
            ui.exportContainer.style.display = 'flex';
          }
        } catch (error) {
          showNotification(error.message, true);
        }
      });

      ui.abortBtn.addEventListener('click', () => {
        if (isLongDurationSession) {
          finishLongDurationSession();
        } else {
          isExperimentRunning = false;
          webgazer.end();
          showNotification('Experiment aborted');
          resetUI();
        }
      });

      ui.exportCSV.addEventListener('click', () => exportData());
      ui.exportJSON.addEventListener('click', () => exportData());

      // Handle window unload
      window.addEventListener('beforeunload', (e) => {
        if (isExperimentRunning && isLongDurationSession) {
          // Try to auto-save if closing during long session
          performAutoSave();
          
          // Show confirmation to prevent accidental closing
          e.preventDefault();
          e.returnValue = 'You have an active recording session. Are you sure you want to leave?';
          return e.returnValue;
        }
        
        if (webgazer) webgazer.end();
        if (psychoJS) psychoJS.quit();
        if (recordingSession) {
          stopRecordingSession();
        }
      });

      // Start a long duration recording session
      async function startLongDurationSession() {
        // Reset stats
        sessionStats = {
          totalDuration: 0,
          activeDuration: 0,
          pauseDuration: 0,
          dataPoints: 0,
          avgTrackingQuality: 1.0,
          segmentCount: 0
        };
        
        // Reset session state
        isLongDurationSession = true;
        currentSegment = 0;
        recordedSegments = [];
        totalPausedTime = 0;
        isPaused = false;
        
        // Update UI
        ui.sessionStats.style.display = 'block';
        ui.statusText.textContent = 'Starting long duration session...';
        
        // Initialize recording components similar to regular recording
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        recordingStartTime = Date.now();
        segmentStartTime = recordingStartTime;
        lastCleanupTime = recordingStartTime;
        
        // Initialize session duration in milliseconds
        const totalSessionDuration = config.longDurationHours * 60 * 60 * 1000;
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object
        recordingSession = {
          id: `long_session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          totalSessionDuration: totalSessionDuration,
          segmentDuration: config.segmentDuration * 1000,
          segments: [],
          currentSegment: {
            id: `segment_0_${Date.now()}`,
            startTime: recordingStartTime,
            frames: []
          },
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        // Update UI elements
        updateSegmentIndicator();
        
        // Start recording loop
        ui.statusText.textContent = 'Long duration recording in progress...';
        isExperimentRunning = true;
        
        // Start auto-save interval
        startAutoSave();
        
        // Start recording loop
        longDurationRecordingLoop();
        
        // Update UI buttons
        ui.pauseResumeBtn.disabled = false;
        ui.saveSegmentBtn.disabled = false;
        
        return true;
      }
      
      // Long duration recording loop
      async function longDurationRecordingLoop() {
        if (!isExperimentRunning) return;
        if (isPaused) {
          // If paused, just update the pause time and continue the loop
          updatePauseTime();
          requestAnimationFrame(longDurationRecordingLoop);
          return;
        }
        
        const now = Date.now();
        const totalElapsedTime = now - recordingStartTime - totalPausedTime;
        const segmentElapsedTime = now - segmentStartTime - totalPausedTime;
        
        // Update session statistics
        currentRecordingTime = totalElapsedTime;
        sessionStats.totalDuration = totalElapsedTime;
        sessionStats.activeDuration = totalElapsedTime - sessionStats.pauseDuration;
        
        // Update progress based on total session duration
        const totalProgress = (totalElapsedTime / (config.longDurationHours * 60 * 60 * 1000)) * 100;
        updateProgress(Math.min(totalProgress, 100));
        
        // Update timeline visualization
        updateTimelineVisualization(totalElapsedTime);
        
        // Check if we need to start a new segment
        const segmentDurationMs = config.segmentDuration * 1000;
        if (segmentElapsedTime >= segmentDurationMs) {
          await saveCurrentSegment();
          startNewSegment();
        }
        
        // Get current gaze prediction
        const prediction = await webgazer.getCurrentPrediction();
        if (prediction) {
          // Get face features for tracking quality calculation
          const faceFeatures = await webgazer.getCurrentFaceFeatures();
          const trackingQuality = calculateTrackingQuality(faceFeatures);
          
          // Reset inactivity timer when we get a good prediction
          resetInactivityTimer();
          
          // Add to history for heatmap with temporal information
          gazeHistory.push({
            x: prediction.x,
            y: prediction.y,
            timestamp: now,
            quality: trackingQuality
          });
          
          // Add to recording data
          const frameData = {
            timestamp: now - recordingStartTime - totalPausedTime,
            gazeX: prediction.x,
            gazeY: prediction.y,
            trackingQuality: trackingQuality,
            headPosition: faceFeatures
          };
          
          recordingSession.frames.push(frameData);
          recordingSession.currentSegment.frames.push(frameData);
          
          // Update stats
          sessionStats.dataPoints++;
          updateSessionStatsUI();
          
          // Draw current gaze point
          drawGazePoint(prediction.x, prediction.y);
          
          // Update heatmap if enabled
          if (heatmapEnabled) {
            updateTemporalHeatmap();
          }
          
          // Update quality indicator
          updateQualityIndicator(trackingQuality);
        }
        
        // Check if we need to perform memory management
        const timeSinceLastCleanup = now - lastCleanupTime;
        if (timeSinceLastCleanup > config.memoryManagement.cleanupInterval * 1000) {
          performMemoryManagement();
          lastCleanupTime = now;
        }
        
        // Check if total session duration has been reached
        const totalSessionDurationMs = config.longDurationHours * 60 * 60 * 1000;
        if (totalElapsedTime >= totalSessionDurationMs) {
          await finishLongDurationSession();
        } else {
          // Continue loop
          requestAnimationFrame(longDurationRecordingLoop);
        }
      }
      
      // Start a new segment in the recording
      function startNewSegment() {
        currentSegment++;
        segmentStartTime = Date.now();
        
        // Create new segment
        recordingSession.currentSegment = {
          id: `segment_${currentSegment}_${Date.now()}`,
          startTime: segmentStartTime,
          frames: []
        };
        
        // Update stats
        sessionStats.segmentCount++;
        
        // Update UI
        updateSegmentIndicator();
        showNotification(`Started segment ${currentSegment + 1}`);
      }
      
      // Save the current segment
      async function saveCurrentSegment() {
        if (!recordingSession || !recordingSession.currentSegment) return;
        
        const segment = recordingSession.currentSegment;
        segment.endTime = Date.now();
        segment.duration = segment.endTime - segment.startTime;
        
        // Add segment to segments array
        recordingSession.segments.push({...segment});
        recordedSegments.push({...segment});
        
        // Notify user
        showNotification(`Saved segment ${currentSegment + 1}`);
        
        // Optionally export the segment
        await exportSegment(segment);
        
        return segment;
      }
      
      // Auto-save functionality
      function startAutoSave() {
        if (autoSaveInterval) {
          clearInterval(autoSaveInterval);
        }
        
        const autoSaveIntervalMs = config.autoSaveInterval * 1000;
        autoSaveInterval = setInterval(async () => {
          if (isExperimentRunning && !isPaused) {
            await performAutoSave();
          }
        }, autoSaveIntervalMs);
      }
      
      // Perform auto-save
      async function performAutoSave() {
        // Create a snapshot of the current recording data
        const snapshot = {
          timestamp: Date.now(),
          sessionData: {...recordingSession},
          sessionStats: {...sessionStats}
        };
        
        // Save to localStorage for recovery purposes
        try {
          localStorage.setItem('eyeTracking_autoSave', JSON.stringify(snapshot));
          showNotification('Session auto-saved');
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }
      
      // Pause/resume the recording
      function togglePauseRecording() {
        if (!isExperimentRunning || !isLongDurationSession) return;
        
        if (isPaused) {
          // Resume recording
          const pauseDuration = Date.now() - pauseStartTime;
          totalPausedTime += pauseDuration;
          sessionStats.pauseDuration += pauseDuration;
          
          isPaused = false;
          ui.pauseResumeBtn.textContent = 'Pause';
          ui.pauseIndicator.style.display = 'none';
          showNotification('Recording resumed');
        } else {
          // Pause recording
          isPaused = true;
          pauseStartTime = Date.now();
          ui.pauseResumeBtn.textContent = 'Resume';
          ui.pauseIndicator.style.display = 'block';
          showNotification('Recording paused');
        }
      }
      
      // Complete a long duration session
      async function finishLongDurationSession() {
        // Save the final segment
        await saveCurrentSegment();
        
        // Stop the recording
        stopRecordingSession();
        
        // Update UI
        ui.statusText.textContent = 'Long duration session completed';
        ui.exportContainer.style.display = 'flex';
        
        // Show completion notification
        showNotification('Long duration session completed successfully');
        
        // Reset flags
        isLongDurationSession = false;
        
        // Generate session summary
        generateSessionSummary();
      }
      
      // Memory management for long recordings
      function performMemoryManagement() {
        // Downsampling factor from config
        const factor = config.memoryManagement.sampleDownsamplingFactor;
        
        // Limit frames in memory if needed
        if (recordingSession.frames.length > config.memoryManagement.maxGazeHistoryPoints) {
          // Only keep the most recent points
          const startIndex = recordingSession.frames.length - config.memoryManagement.maxGazeHistoryPoints;
          recordingSession.frames = recordingSession.frames.slice(startIndex);
        }
        
        // Limit gaze history for visualization
        if (gazeHistory.length > config.memoryManagement.maxGazeHistoryPoints) {
          // Only keep recent points
          const startIndex = gazeHistory.length - config.memoryManagement.maxGazeHistoryPoints;
          gazeHistory = gazeHistory.slice(startIndex);
        }
        
        // Apply downsampling if factor > 1
        if (factor > 1 && recordingSession.frames.length > 1000) {
          // Keep every Nth frame
          recordingSession.frames = recordingSession.frames.filter((_, index) => index % factor === 0);
          showNotification(`Memory optimized: Downsampled by ${factor}x`);
        }
      }
      
      // Reset inactivity timer
      function resetInactivityTimer() {
        if (inactivityTimer) {
          clearTimeout(inactivityTimer);
        }
        
        // Only set up inactivity detection if enabled
        if (config.pauseDetection.enabled) {
          inactivityTimer = setTimeout(() => {
            // Auto-pause if we're in a long duration session and not already paused
            if (isLongDurationSession && isExperimentRunning && !isPaused) {
              showNotification('Auto-paused due to inactivity', true);
              togglePauseRecording();
            }
          }, config.pauseDetection.inactivityThreshold * 1000);
        }
      }
      
      // Calculate tracking quality from face features
      function calculateTrackingQuality(faceFeatures) {
        // Simple quality metric (customize based on your needs)
        if (!faceFeatures) return 0;
        
        // Calculate based on face detection confidence or other metrics
        // This is a simplified example
        let quality = 1.0;
        
        // Adjust quality based on face position, size, etc.
        if (faceFeatures.width < 100 || faceFeatures.height < 100) {
          quality *= 0.8; // Face too small
        }
        
        lastTrackingQuality = quality;
        return quality;
      }
      
      // Update quality indicator
      function updateQualityIndicator(quality) {
        const indicator = document.getElementById('qualityIndicator');
        
        if (quality > 0.7) {
          indicator.className = 'quality-indicator';
        } else if (quality > 0.4) {
          indicator.className = 'quality-indicator medium';
        } else {
          indicator.className = 'quality-indicator low';
        }
      }
      
      // Export a single segment
      async function exportSegment(segment) {
        if (!segment || segment.frames.length === 0) return;
        
        // Prepare segment data for export
        const segmentData = {
          id: segment.id,
          startTime: segment.startTime,
          endTime: segment.endTime || Date.now(),
          duration: segment.duration || (Date.now() - segment.startTime),
          framesCount: segment.frames.length,
          frames: segment.frames
        };
        
        // Export JSON format (can add CSV format as needed)
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(segmentData));
        
        // Create download link - but don't auto-download to avoid browser blocking
        // Just store for later batch download
        segment.exportData = jsonContent;
        
        return segmentData;
      }
      
      // Export all segments
      function exportAllSegments() {
        if (!recordedSegments || recordedSegments.length === 0) {
          showNotification('No segments available to export', true);
          return;
        }
        
        // Create a zip-like format with all segments
        const allSegmentsData = {
          sessionId: recordingSession?.id || `session_${Date.now()}`,
          startTime: recordingSession?.startTime || recordedSegments[0].startTime,
          endTime: Date.now(),
          segmentsCount: recordedSegments.length,
          totalDataPoints: sessionStats.dataPoints,
          segments: recordedSegments.map(segment => ({
            id: segment.id,
            startTime: segment.startTime,
            endTime: segment.endTime || Date.now(),
            duration: segment.duration || (Date.now() - segment.startTime),
            framesCount: segment.frames.length
          })),
          stats: sessionStats
        };
        
        // Create JSON download
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(allSegmentsData));
        
        // Create download link
        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = `eye_tracking_session_${Date.now()}.json`;
        jsonLink.click();
        
        showNotification(`Exported ${recordedSegments.length} segments`);
      }
      
      // Update segment indicator in UI
      function updateSegmentIndicator() {
        const container = document.getElementById('segmentIndicator');
        container.innerHTML = '';
        
        // Calculate how many segments we expect in total
        const totalDurationMs = config.longDurationHours * 60 * 60 * 1000;
        const segmentDurationMs = config.segmentDuration * 1000;
        const expectedSegments = Math.ceil(totalDurationMs / segmentDurationMs);
        
        // Create segment indicators
        for (let i = 0; i < expectedSegments; i++) {
          const dot = document.createElement('div');
          dot.className = 'segment-dot';
          
          if (i < currentSegment) {
            dot.classList.add('completed');
          } else if (i === currentSegment) {
            dot.classList.add('active');
          }
          
          container.appendChild(dot);
        }
      }
      
      // Format time for display (HH:MM:SS)
      function formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        return [
          hours.toString().padStart(2, '0'),
          minutes.toString().padStart(2, '0'),
          seconds.toString().padStart(2, '0')
        ].join(':');
      }
      
      // Update session statistics UI
      function updateSessionStatsUI() {
        document.getElementById('totalTimeValue').textContent = formatTime(sessionStats.totalDuration);
        document.getElementById('activeTimeValue').textContent = formatTime(sessionStats.activeDuration);
        document.getElementById('pauseTimeValue').textContent = formatTime(sessionStats.pauseDuration);
        document.getElementById('dataPointsValue').textContent = sessionStats.dataPoints.toLocaleString();
        document.getElementById('trackingQualityValue').textContent = `${Math.round(lastTrackingQuality * 100)}%`;
        document.getElementById('segmentCountValue').textContent = sessionStats.segmentCount + 1; // +1 for current segment
      }
      
      // Update pause time counter
      function updatePauseTime() {
        if (isPaused) {
          const currentPauseDuration = Date.now() - pauseStartTime;
          document.getElementById('pauseTimeValue').textContent = formatTime(sessionStats.pauseDuration + currentPauseDuration);
        }
      }
      
      // Update timeline visualization
      function updateTimelineVisualization(currentTimeMs) {
        const timeline = document.getElementById('sessionTimeline');
        const cursor = document.getElementById('timelineCursor');
        
        // Clear existing segments
        const existingSegments = timeline.querySelectorAll('.timeline-segment');
        existingSegments.forEach(el => el.remove());
        
        // Add completed segments
        const totalDurationMs = config.longDurationHours * 60 * 60 * 1000;
        recordedSegments.forEach((segment, index) => {
          const segmentEl = document.createElement('div');
          segmentEl.className = 'timeline-segment';
          
          // Position the segment on the timeline
          const startPercent = (segment.startTime - recordingStartTime - totalPausedTime) / totalDurationMs * 100;
          const endPercent = ((segment.endTime || Date.now()) - recordingStartTime - totalPausedTime) / totalDurationMs * 100;
          const width = endPercent - startPercent;
          
          segmentEl.style.left = `${startPercent}%`;
          segmentEl.style.width = `${width}%`;
          
          timeline.appendChild(segmentEl);
        });
        
        // Position the current time cursor
        const cursorPosition = (currentTimeMs / totalDurationMs) * 100;
        cursor.style.left = `${cursorPosition}%`;
      }
      
      // Update heatmap with temporal weighting
      function updateTemporalHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Get current time for temporal weighting
        const now = Date.now();
        const timeWindow = config.visualization.timeWindow * 1000; // convert to ms
        
        // Populate grid with gaze data with temporal weighting
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          // Only include points in the visualization time window
          if (now - point.timestamp <= timeWindow) {
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
              // Apply temporal weighting - more recent points have higher weight
              const age = (now - point.timestamp) / timeWindow;
              const weight = Math.pow(config.visualization.heatmapTemporalDecay, age);
              heatGrid[gridY][gridX] += weight;
            }
          }
        });
        
        // Draw heatmap (similar to existing implementation but with temporal weights)
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Apply settings from the settings panel
      function applySettings() {
        // Get values from form
        const hours = parseFloat(document.getElementById('sessionDurationHours').value);
        const segmentDurationMinutes = parseInt(document.getElementById('segmentDuration').value);
        const autoSaveIntervalMinutes = parseInt(document.getElementById('autoSaveInterval').value);
        const maxGazePoints = parseInt(document.getElementById('maxGazePoints').value);
        const downsamplingFactor = parseInt(document.getElementById('downsamplingFactor').value);
        const pauseDetectionEnabled = document.getElementById('pauseDetectionEnabled').checked;
        const inactivityThreshold = parseInt(document.getElementById('inactivityThreshold').value);
        
        // Update config
        config.longDurationHours = hours;
        config.segmentDuration = segmentDurationMinutes * 60; // convert to seconds
        config.autoSaveInterval = autoSaveIntervalMinutes * 60; // convert to seconds
        config.memoryManagement.maxGazeHistoryPoints = maxGazePoints;
        config.memoryManagement.sampleDownsamplingFactor = downsamplingFactor;
        config.pauseDetection.enabled = pauseDetectionEnabled;
        config.pauseDetection.inactivityThreshold = inactivityThreshold;
        
        // Update auto-save interval if running
        if (autoSaveInterval) {
          clearInterval(autoSaveInterval);
          startAutoSave();
        }
        
        // Hide settings panel
        document.getElementById('settingsPanel').style.display = 'none';
        
        showNotification('Settings applied');
      }
      
      // Generate session summary at the end
      function generateSessionSummary() {
        // Create a printable summary
        const summary = {
          sessionId: recordingSession?.id,
          duration: {
            total: formatTime(sessionStats.totalDuration),
            active: formatTime(sessionStats.activeDuration),
            paused: formatTime(sessionStats.pauseDuration)
          },
          segments: sessionStats.segmentCount,
          dataPoints: sessionStats.dataPoints,
          avgQuality: `${Math.round(sessionStats.avgTrackingQuality * 100)}%`,
          timestamp: new Date().toISOString()
        };
        
        console.log('Session Summary:', summary);
        return summary;
      }
    </script>
  </body>
</html>