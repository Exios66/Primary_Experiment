<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Advanced Eye Tracking Experiment</title>
    
    <!-- Modern dependencies -->
    <script src="https://unpkg.com/psychojs@2023.2.3/dist/psychojs.js"></script>
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --primary-color: #2563eb;
        --secondary-color: #1e40af;
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --error-color: #ef4444;
        --success-color: #22c55e;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .experiment-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 2rem;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        background: var(--primary-color);
        color: white;
      }

      .btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        height: 8px;
        margin: 1rem 0;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: var(--primary-color);
        transition: width 0.3s ease;
        width: 0%;
      }

      .calibration-point {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .export-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        margin-top: 2rem;
      }

      .export-btn {
        background: transparent;
        border: 2px solid var(--primary-color);
        color: var(--text-color);
      }

      .export-btn:hover {
        background: var(--primary-color);
      }

      .notification {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        padding: 1rem;
        border-radius: 6px;
        background: var(--success-color);
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .notification.show {
        opacity: 1;
      }

      .error {
        background: var(--error-color);
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .controls {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Eye Tracking Experiment</h1>
        <p>Advanced gaze tracking using WebGazer.js and PsychoJS</p>
      </div>

      <div class="experiment-status">
        <h2>Status</h2>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <p id="statusText">Initializing experiment...</p>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn" type="button">Start Experiment</button>
        <button class="btn" id="calibrateBtn" type="button" disabled>Calibrate</button>
        <button class="btn" id="abortBtn" type="button" disabled>Stop Experiment</button>
      </div>

      <div id="experimentContainer"></div>

      <div class="export-container" id="exportContainer" style="display: none;">
        <button class="btn export-btn" id="exportCSV" type="button">Download CSV Data</button>
        <button class="btn export-btn" id="exportJSON" type="button">Download JSON Data</button>
      </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
      // Global state
      let psychoJS;
      let experimentWindow;
      let gazeData = [];
      let calibrationData = [];
      let isExperimentRunning = false;
      let currentTrial = 0;
      let heatmapEnabled = false;
      let recordingSession = null;
      let headCalibrationData = null;
      let coordinatePlane = null;
      let heatmapLayer = null;
      let gazeHistory = [];
      let recordingStartTime = null;

      // Configuration
      const config = {
        fullscreen: true,
        backgroundColor: '#0f172a',
        frameRate: 60,
        calibrationPoints: 9,
        trialCount: 5,
        sampleRate: 30,
        heatmapResolution: 50,
        heatmapOpacity: 0.6,
        heatmapRadius: 50,
        heatmapColorScale: ['blue', 'green', 'yellow', 'red'],
        coordinatePlaneColor: 'rgba(255, 255, 255, 0.2)',
        coordinatePlaneSpacing: 50,
        recordingDuration: 60, // seconds
        headCalibrationSamples: 30
      };

      // UI Elements
      const ui = {
        startBtn: document.getElementById('startBtn'),
        calibrateBtn: document.getElementById('calibrateBtn'),
        abortBtn: document.getElementById('abortBtn'),
        progressBar: document.getElementById('progressBar'),
        statusText: document.getElementById('statusText'),
        notification: document.getElementById('notification'),
        exportContainer: document.getElementById('exportContainer')
      };

      // Initialize WebGazer
      async function initializeWebGazer() {
        try {
          await webgazer.setGazeListener((data, timestamp) => {
            if (data && isExperimentRunning) {
              gazeData.push({
                timestamp,
                x: data.x,
                y: data.y,
                trial: currentTrial
              });
            }
          }).begin();

          // Configure WebGazer
          webgazer.showVideo(false)
                  .showFaceOverlay(false)
                  .showFaceFeedbackBox(false)
                  .showPredictionPoints(false);

          return true;
        } catch (error) {
          showNotification('Failed to initialize WebGazer: ' + error.message, true);
          return false;
        }
      }

      // Initialize PsychoJS
      function initializePsychoJS() {
        psychoJS = new PsychoJS({
          debug: true
        });

        experimentWindow = new psychoJS.visual.Window({
          size: [window.innerWidth, window.innerHeight],
          fullscr: config.fullscreen,
          color: new psychoJS.Color(config.backgroundColor),
          units: 'norm'
        });

        return true;
      }

      // Calibration procedure
      async function runCalibration() {
        const points = [
          [-0.8, 0.8], [0, 0.8], [0.8, 0.8],
          [-0.8, 0], [0, 0], [0.8, 0],
          [-0.8, -0.8], [0, -0.8], [0.8, -0.8]
        ];

        calibrationData = [];
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          
          // Create calibration point
          const dot = new psychoJS.visual.Circle({
            win: experimentWindow,
            radius: 0.02,
            pos: point,
            fillColor: new psychoJS.Color('white'),
            lineWidth: 0
          });

          // Show point
          dot.draw();
          experimentWindow.flip();

          // Wait for fixation
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Collect samples
          const samples = [];
          for (let j = 0; j < 10; j++) {
            const prediction = await webgazer.getCurrentPrediction();
            if (prediction) {
              samples.push({
                x: prediction.x,
                y: prediction.y
              });
            }
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          // Calculate average
          if (samples.length > 0) {
            const avgX = samples.reduce((sum, s) => sum + s.x, 0) / samples.length;
            const avgY = samples.reduce((sum, s) => sum + s.y, 0) / samples.length;
            
            calibrationData.push({
              target: point,
              measured: [avgX, avgY]
            });
          }

          // Update progress
          updateProgress((i + 1) / points.length * 100);
        }

        return calibrationData.length === points.length;
      }

      // Initialize coordinate plane for screen
      function initCoordinatePlane() {
        coordinatePlane = document.createElement('div');
        coordinatePlane.id = 'coordinatePlane';
        coordinatePlane.style.position = 'absolute';
        coordinatePlane.style.top = '0';
        coordinatePlane.style.left = '0';
        coordinatePlane.style.width = '100%';
        coordinatePlane.style.height = '100%';
        coordinatePlane.style.pointerEvents = 'none';
        coordinatePlane.style.zIndex = '1000';
        document.body.appendChild(coordinatePlane);
        
        // Create canvas for coordinate plane
        const canvas = document.createElement('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        coordinatePlane.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = config.coordinatePlaneColor;
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        
        // Add coordinate labels
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = x;
          label.style.position = 'absolute';
          label.style.left = `${x}px`;
          label.style.top = '5px';
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = y;
          label.style.position = 'absolute';
          label.style.left = '5px';
          label.style.top = `${y}px`;
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        return coordinatePlane;
      }
      
      // Initialize heatmap layer
      function initHeatmap() {
        if (heatmapLayer) {
          document.body.removeChild(heatmapLayer);
        }
        
        heatmapLayer = document.createElement('canvas');
        heatmapLayer.id = 'heatmapLayer';
        heatmapLayer.width = window.innerWidth;
        heatmapLayer.height = window.innerHeight;
        heatmapLayer.style.position = 'absolute';
        heatmapLayer.style.top = '0';
        heatmapLayer.style.left = '0';
        heatmapLayer.style.pointerEvents = 'none';
        heatmapLayer.style.opacity = config.heatmapOpacity;
        heatmapLayer.style.zIndex = '999';
        document.body.appendChild(heatmapLayer);
        
        return heatmapLayer;
      }
      
      // Update heatmap based on gaze history
      function updateHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure (simple 2D grid)
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Populate grid with gaze data
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            heatGrid[gridY][gridX] += 1;
          }
        });
        
        // Find maximum value for normalization
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        // Draw heatmap
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Head position and tilt calibration
      async function calibrateHeadPosition() {
        ui.statusText.textContent = 'Head Position Calibration...';
        updateProgress(0);
        
        // Create visual guide for head position
        const headGuide = document.createElement('div');
        headGuide.style.position = 'absolute';
        headGuide.style.top = '50%';
        headGuide.style.left = '50%';
        headGuide.style.transform = 'translate(-50%, -50%)';
        headGuide.style.width = '300px';
        headGuide.style.height = '300px';
        headGuide.style.border = '2px dashed white';
        headGuide.style.borderRadius = '50%';
        headGuide.style.zIndex = '1001';
        document.body.appendChild(headGuide);
        
        // Text instructions
        const instructions = document.createElement('div');
        instructions.textContent = 'Position your head in the center and remain still';
        instructions.style.position = 'absolute';
        instructions.style.top = 'calc(50% + 170px)';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.color = 'white';
        instructions.style.fontSize = '18px';
        instructions.style.fontWeight = 'bold';
        instructions.style.zIndex = '1002';
        document.body.appendChild(instructions);
        
        // Collect head position samples
        const samples = [];
        for (let i = 0; i < config.headCalibrationSamples; i++) {
          updateProgress((i / config.headCalibrationSamples) * 100);
          
          // Get current face position from WebGazer
          const currentFace = await new Promise(resolve => {
            webgazer.getCurrentFaceFeatures().then(features => {
              resolve(features);
            });
          });
          
          if (currentFace) {
            samples.push(currentFace);
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Calculate average head position and orientation
        if (samples.length > 0) {
          headCalibrationData = {
            timestamp: Date.now(),
            samples: samples,
            averagePosition: calculateAverageHeadPosition(samples)
          };
          
          showNotification('Head position calibrated successfully');
        } else {
          showNotification('Head calibration failed. Please try again.', true);
        }
        
        // Clean up
        document.body.removeChild(headGuide);
        document.body.removeChild(instructions);
        
        return samples.length > 0;
      }
      
      // Calculate average head position from samples
      function calculateAverageHeadPosition(samples) {
        if (!samples || samples.length === 0) return null;
        
        // This is a simplified version - in a real implementation,
        // you would extract more detailed face metrics
        const avgPosition = { x: 0, y: 0, width: 0, height: 0 };
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            avgPosition.x += sample.imagex;
            avgPosition.y += sample.imagey;
            avgPosition.width += sample.width;
            avgPosition.height += sample.height;
          }
        });
        
        avgPosition.x /= samples.length;
        avgPosition.y /= samples.length;
        avgPosition.width /= samples.length;
        avgPosition.height /= samples.length;
        
        return avgPosition;
      }
      
      // Start recording session
      async function startRecordingSession() {
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        recordingStartTime = Date.now();
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object
        recordingSession = {
          id: `session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        // Start recording loop
        ui.statusText.textContent = 'Recording in progress...';
        isExperimentRunning = true;
        
        const recordingLoop = async () => {
          if (!isExperimentRunning) return;
          
          const elapsedTime = (Date.now() - recordingStartTime) / 1000;
          updateProgress((elapsedTime / config.recordingDuration) * 100);
          
          // Get current gaze prediction
          const prediction = await webgazer.getCurrentPrediction();
          if (prediction) {
            // Add to history for heatmap
            gazeHistory.push({
              x: prediction.x,
              y: prediction.y,
              timestamp: Date.now() - recordingStartTime
            });
            
            // Add to recording data
            recordingSession.frames.push({
              timestamp: Date.now() - recordingStartTime,
              gazeX: prediction.x,
              gazeY: prediction.y,
              headPosition: await webgazer.getCurrentFaceFeatures()
            });
            
            // Draw current gaze point
            drawGazePoint(prediction.x, prediction.y);
            
            // Update heatmap if enabled
            if (heatmapEnabled) {
              updateHeatmap();
            }
          }
          
          // Check if recording duration has been reached
          if (elapsedTime >= config.recordingDuration) {
            stopRecordingSession();
            showNotification('Recording completed');
            ui.exportContainer.style.display = 'flex';
          } else {
            // Continue loop
            requestAnimationFrame(recordingLoop);
          }
        };
        
        // Start the recording loop
        recordingLoop();
        
        return true;
      }
      
      // Stop recording session
      function stopRecordingSession() {
        isExperimentRunning = false;
        
        if (recordingSession) {
          recordingSession.endTime = Date.now();
          recordingSession.duration = recordingSession.endTime - recordingSession.startTime;
          
          // Save recording data
          gazeData = recordingSession.frames;
          
          // Clean up
          if (coordinatePlane) {
            document.body.removeChild(coordinatePlane);
            coordinatePlane = null;
          }
          
          if (heatmapLayer) {
            document.body.removeChild(heatmapLayer);
            heatmapLayer = null;
          }
          
          ui.statusText.textContent = 'Recording stopped';
          updateProgress(100);
        }
      }
      
      // Draw current gaze point
      function drawGazePoint(x, y) {
        // Remove previous gaze point if exists
        const existingPoint = document.getElementById('currentGazePoint');
        if (existingPoint) {
          document.body.removeChild(existingPoint);
        }
        
        // Create new gaze point
        const gazePoint = document.createElement('div');
        gazePoint.id = 'currentGazePoint';
        gazePoint.style.position = 'absolute';
        gazePoint.style.top = `${y}px`;
        gazePoint.style.left = `${x}px`;
        gazePoint.style.width = '20px';
        gazePoint.style.height = '20px';
        gazePoint.style.borderRadius = '50%';
        gazePoint.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        gazePoint.style.transform = 'translate(-50%, -50%)';
        gazePoint.style.zIndex = '1003';
        gazePoint.style.pointerEvents = 'none';
        document.body.appendChild(gazePoint);
        
        // Add ripple effect
        const ripple = document.createElement('div');
        ripple.style.position = 'absolute';
        ripple.style.top = '50%';
        ripple.style.left = '50%';
        ripple.style.width = '100%';
        ripple.style.height = '100%';
        ripple.style.borderRadius = '50%';
        ripple.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        ripple.style.transform = 'translate(-50%, -50%) scale(1)';
        ripple.style.transition = 'all 0.5s ease-out';
        gazePoint.appendChild(ripple);
        
        setTimeout(() => {
          ripple.style.transform = 'translate(-50%, -50%) scale(2)';
          ripple.style.opacity = '0';
        }, 10);
      }
      
      // Toggle heatmap visibility
      function toggleHeatmap() {
        heatmapEnabled = !heatmapEnabled;
        
        if (heatmapEnabled) {
          if (!heatmapLayer) {
            initHeatmap();
          }
          updateHeatmap();
          showNotification('Heatmap enabled');
        } else {
          if (heatmapLayer) {
            const ctx = heatmapLayer.getContext('2d');
            ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
          }
          showNotification('Heatmap disabled');
        }
      }
      
      // Export recording data
      function exportRecordingData() {
        if (!recordingSession || recordingSession.frames.length === 0) {
          showNotification('No recording data available', true);
          return;
        }
        
        // Prepare CSV data
        const csvContent = "data:text/csv;charset=utf-8," + 
          "timestamp,gazeX,gazeY,headX,headY,headWidth,headHeight\n" +
          recordingSession.frames.map(frame => {
            const head = frame.headPosition || {};
            return `${frame.timestamp},${frame.gazeX},${frame.gazeY},` +
                   `${head.imagex || ''},${head.imagey || ''},` +
                   `${head.width || ''},${head.height || ''}`;
          }).join("\n");
        
        // Create download link
        const csvLink = document.createElement('a');
        csvLink.href = encodeURI(csvContent);
        csvLink.download = `gaze_recording_${recordingSession.id}.csv`;
        csvLink.click();
        
        // Prepare JSON data
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify({
            sessionInfo: {
              id: recordingSession.id,
              startTime: recordingSession.startTime,
              endTime: recordingSession.endTime,
              duration: recordingSession.duration,
              screenDimensions: recordingSession.screenDimensions
            },
            headCalibration: recordingSession.headCalibration,
            frames: recordingSession.frames
          }));
        
        // Create download link
        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = `gaze_recording_${recordingSession.id}.json`;
        jsonLink.click();
        
        showNotification('Recording data exported');
      }

      // Run a single trial
      async function runTrial(trialNumber) {
        currentTrial = trialNumber;
        
        // Show fixation cross
        const fixation = new psychoJS.visual.TextStim({
          win: experimentWindow,
          text: '+',
          height: 0.1,
          color: new psychoJS.Color('white')
        });

        fixation.draw();
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Show stimulus
        const stimulus = new psychoJS.visual.TextStim({
          win: experimentWindow,
          text: `Trial ${trialNumber}`,
          height: 0.1,
          color: new psychoJS.Color('white')
        });

        stimulus.draw();
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Inter-trial interval
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      // Export data
      function exportData() {
        // CSV Export
        const csvContent = "data:text/csv;charset=utf-8," + 
          "timestamp,x,y,trial\n" +
          gazeData.map(row => 
            `${row.timestamp},${row.x},${row.y},${row.trial}`
          ).join("\n");

        const csvLink = document.createElement('a');
        csvLink.href = encodeURI(csvContent);
        csvLink.download = 'gaze_data.csv';
        csvLink.click();

        // JSON Export
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(gazeData));

        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = 'gaze_data.json';
        jsonLink.click();
      }

      // UI Updates
      function updateProgress(percent) {
        ui.progressBar.style.width = `${percent}%`;
      }

      function showNotification(message, isError = false) {
        ui.notification.textContent = message;
        ui.notification.classList.toggle('error', isError);
        ui.notification.classList.add('show');
        setTimeout(() => ui.notification.classList.remove('show'), 3000);
      }

      function resetUI() {
        ui.calibrateBtn.disabled = true;
        ui.abortBtn.disabled = true;
        ui.progressBar.style.width = '0%';
        ui.statusText.textContent = 'Experiment ready';
        ui.exportContainer.style.display = 'none';
      }

      // MODIFY EXISTING UI ELEMENTS AND ADD NEW ONES
      document.addEventListener('DOMContentLoaded', () => {
        // Add new buttons for the second pipeline
        const controls = document.querySelector('.controls');
        
        // Add heatmap toggle button
        const heatmapBtn = document.createElement('button');
        heatmapBtn.id = 'heatmapBtn';
        heatmapBtn.className = 'btn';
        heatmapBtn.type = 'button';
        heatmapBtn.textContent = 'Toggle Heatmap';
        heatmapBtn.disabled = true;
        controls.appendChild(heatmapBtn);
        
        // Add head calibration button
        const headCalibBtn = document.createElement('button');
        headCalibBtn.id = 'headCalibBtn';
        headCalibBtn.className = 'btn';
        headCalibBtn.type = 'button';
        headCalibBtn.textContent = 'Calibrate Head Position';
        headCalibBtn.disabled = true;
        controls.appendChild(headCalibBtn);
        
        // Add recording button
        const recordBtn = document.createElement('button');
        recordBtn.id = 'recordBtn';
        recordBtn.className = 'btn';
        recordBtn.type = 'button';
        recordBtn.textContent = 'Start Recording';
        recordBtn.disabled = true;
        controls.appendChild(recordBtn);
        
        // Update UI object with new elements
        ui.heatmapBtn = heatmapBtn;
        ui.headCalibBtn = headCalibBtn;
        ui.recordBtn = recordBtn;
        
        // Add event listeners for new buttons
        ui.heatmapBtn.addEventListener('click', toggleHeatmap);
        
        ui.headCalibBtn.addEventListener('click', async () => {
          try {
            const headCalibrationSuccess = await calibrateHeadPosition();
            if (headCalibrationSuccess) {
              ui.recordBtn.disabled = false;
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.recordBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning) {
              stopRecordingSession();
              ui.recordBtn.textContent = 'Start Recording';
            } else {
              const recordingStarted = await startRecordingSession();
              if (recordingStarted) {
                ui.recordBtn.textContent = 'Stop Recording';
                ui.heatmapBtn.disabled = false;
              }
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        // Modify existing event listeners
        ui.startBtn.addEventListener('click', async () => {
          try {
            const webgazerInitialized = await initializeWebGazer();
            const psychojsInitialized = initializePsychoJS();

            if (webgazerInitialized && psychojsInitialized) {
              ui.calibrateBtn.disabled = false;
              ui.abortBtn.disabled = false;
              ui.headCalibBtn.disabled = false;
              showNotification('Experiment initialized successfully');
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.key === 'h' || e.key === 'H') {
            if (!ui.heatmapBtn.disabled) {
              toggleHeatmap();
            }
          } else if (e.key === 'Escape') {
            if (isExperimentRunning) {
              stopRecordingSession();
              ui.recordBtn.textContent = 'Start Recording';
              showNotification('Recording stopped with ESC key');
            }
          }
        });
      });

      // Event Handlers
      ui.startBtn.addEventListener('click', async () => {
        try {
          const webgazerInitialized = await initializeWebGazer();
          const psychojsInitialized = initializePsychoJS();

          if (webgazerInitialized && psychojsInitialized) {
            ui.calibrateBtn.disabled = false;
            ui.abortBtn.disabled = false;
            ui.headCalibBtn.disabled = false;
            showNotification('Experiment initialized successfully');
          }
        } catch (error) {
          showNotification(error.message, true);
        }
      });

      ui.calibrateBtn.addEventListener('click', async () => {
        try {
          ui.statusText.textContent = 'Calibrating...';
          const calibrationSuccess = await runCalibration();
          
          if (calibrationSuccess) {
            showNotification('Calibration completed successfully');
            isExperimentRunning = true;
            
            // Run trials
            for (let trial = 1; trial <= config.trialCount; trial++) {
              if (!isExperimentRunning) break;
              await runTrial(trial);
              updateProgress(trial / config.trialCount * 100);
            }

            // Show export options
            ui.exportContainer.style.display = 'flex';
          }
        } catch (error) {
          showNotification(error.message, true);
        }
      });

      ui.abortBtn.addEventListener('click', () => {
        isExperimentRunning = false;
        webgazer.end();
        showNotification('Experiment aborted');
        resetUI();
      });

      ui.exportCSV.addEventListener('click', () => exportData());
      ui.exportJSON.addEventListener('click', () => exportData());

      // Handle window unload
      window.addEventListener('beforeunload', () => {
        if (webgazer) webgazer.end();
        if (psychoJS) psychoJS.quit();
        if (recordingSession) {
          stopRecordingSession();
        }
      });
    </script>
  </body>
</html>