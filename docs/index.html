<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Advanced Eye Tracking Experiment</title>
    
    <!-- Modern dependencies -->
    <script src="https://unpkg.com/psychojs@2023.2.3/dist/psychojs.js"></script>
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
      :root {
        --primary-color: #2563eb;
        --secondary-color: #1e40af;
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --error-color: #ef4444;
        --success-color: #22c55e;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .experiment-status {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        margin-bottom: 2rem;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        background: var(--primary-color);
        color: white;
      }

      .btn:hover {
        background: var(--secondary-color);
        transform: translateY(-1px);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        height: 8px;
        margin: 1rem 0;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        background: var(--primary-color);
        transition: width 0.3s ease;
        width: 0%;
      }

      .calibration-point {
        position: absolute;
        width: 20px;
        height: 20px;
        background: var(--primary-color);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      .export-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        margin-top: 2rem;
      }

      .export-btn {
        background: transparent;
        border: 2px solid var(--primary-color);
        color: var(--text-color);
      }

      .export-btn:hover {
        background: var(--primary-color);
      }

      .notification {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        padding: 1rem;
        border-radius: 6px;
        background: var(--success-color);
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .notification.show {
        opacity: 1;
      }

      .error {
        background: var(--error-color);
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .controls {
          flex-direction: column;
        }
      }
      
      /* Long duration session styles */
      .session-stats {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        display: none;
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        margin-top: 0.5rem;
      }
      
      .stat-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 0.75rem;
        border-radius: 4px;
        text-align: center;
      }
      
      .stat-value {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--primary-color);
      }
      
      .stat-label {
        font-size: 0.8rem;
        opacity: 0.7;
      }
      
      .segment-indicator {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 1rem;
      }
      
      .segment-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
      }
      
      .segment-dot.active {
        background: var(--primary-color);
      }
      
      .segment-dot.completed {
        background: var(--success-color);
      }
      
      .long-duration-controls {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        flex-wrap: wrap;
        justify-content: center;
        display: none;
      }
      
      .settings-panel {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 1.5rem;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      }
      
      .settings-group {
        margin-bottom: 1.5rem;
      }
      
      .settings-group h3 {
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 0.5rem;
      }
      
      .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 0.75rem;
      }
      
      .form-row label {
        flex: 1;
      }
      
      .form-row input, .form-row select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.5rem;
        border-radius: 4px;
        color: var(--text-color);
        width: 120px;
      }
      
      .close-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: none;
        color: var(--text-color);
        font-size: 1.5rem;
        cursor: pointer;
        opacity: 0.7;
      }
      
      .close-btn:hover {
        opacity: 1;
      }
      
      .pause-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 2rem;
        border-radius: 8px;
        text-align: center;
        z-index: 1100;
        display: none;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }
      
      .pause-indicator h2 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      
      .pulse {
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }
      
      .quality-indicator {
        position: fixed;
        top: 1rem;
        right: 1rem;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--success-color);
        z-index: 1000;
      }
      
      .quality-indicator.medium {
        background: orange;
      }
      
      .quality-indicator.low {
        background: var(--error-color);
      }
      
      /* Timeline visualization for long sessions */
      .timeline {
        height: 2rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        margin-top: 1rem;
        position: relative;
        overflow: hidden;
      }
      
      .timeline-segment {
        position: absolute;
        height: 100%;
        background: var(--primary-color);
        opacity: 0.6;
      }
      
      .timeline-cursor {
        position: absolute;
        width: 2px;
        height: 100%;
        background: white;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Eye Tracking Experiment</h1>
        <p>Advanced gaze tracking using WebGazer.js and PsychoJS</p>
      </div>

      <div class="experiment-status">
        <h2>Status</h2>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <p id="statusText">Initializing experiment...</p>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn" type="button">Start Experiment</button>
        <button class="btn" id="calibrateBtn" type="button" disabled>Calibrate</button>
        <button class="btn" id="abortBtn" type="button" disabled>Stop Experiment</button>
      </div>

      <div class="long-duration-controls" id="longDurationControls">
        <button class="btn" id="startLongSessionBtn" type="button">Start Long Session</button>
        <button class="btn" id="pauseResumeBtn" type="button" disabled>Pause</button>
        <button class="btn" id="settingsBtn" type="button">Settings</button>
        <button class="btn" id="saveSegmentBtn" type="button" disabled>Save Segment</button>
      </div>
      
      <div class="session-stats" id="sessionStats">
        <h3>Long Duration Session Statistics</h3>
        <div class="timeline" id="sessionTimeline">
          <div class="timeline-cursor" id="timelineCursor"></div>
        </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="totalTimeValue">00:00:00</div>
            <div class="stat-label">Total Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="activeTimeValue">00:00:00</div>
            <div class="stat-label">Active Recording</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="pauseTimeValue">00:00:00</div>
            <div class="stat-label">Pause Time</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="dataPointsValue">0</div>
            <div class="stat-label">Data Points</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="trackingQualityValue">100%</div>
            <div class="stat-label">Tracking Quality</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="segmentCountValue">0</div>
            <div class="stat-label">Segments</div>
          </div>
        </div>
        <div class="segment-indicator" id="segmentIndicator"></div>
      </div>

      <div id="experimentContainer"></div>

      <div class="export-container" id="exportContainer" style="display: none;">
        <button class="btn export-btn" id="exportCSV" type="button">Download CSV Data</button>
        <button class="btn export-btn" id="exportJSON" type="button">Download JSON Data</button>
        <button class="btn export-btn" id="exportAllSegments" type="button">Download All Segments</button>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-btn" id="closeSettingsBtn">&times;</button>
        <h2>Long Duration Session Settings</h2>
        
        <div class="settings-group">
          <h3>Session Duration</h3>
          <div class="form-row">
            <label for="sessionDurationHours">Session Length (hours)</label>
            <input type="number" id="sessionDurationHours" min="0.1" max="24" step="0.1" value="1">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Segmentation</h3>
          <div class="form-row">
            <label for="segmentDuration">Segment Length (minutes)</label>
            <input type="number" id="segmentDuration" min="1" max="60" step="1" value="10">
          </div>
          <div class="form-row">
            <label for="autoSaveInterval">Auto-save Interval (minutes)</label>
            <input type="number" id="autoSaveInterval" min="1" max="30" step="1" value="5">
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Memory Management</h3>
          <div class="form-row">
            <label for="maxGazePoints">Max Points in Memory</label>
            <input type="number" id="maxGazePoints" min="1000" max="100000" step="1000" value="10000">
          </div>
          <div class="form-row">
            <label for="downsamplingFactor">Downsampling Factor</label>
            <select id="downsamplingFactor">
              <option value="1">None (1x)</option>
              <option value="2">Light (2x)</option>
              <option value="5">Medium (5x)</option>
              <option value="10">Heavy (10x)</option>
            </select>
          </div>
        </div>
        
        <div class="settings-group">
          <h3>Auto-pause Detection</h3>
          <div class="form-row">
            <label for="pauseDetectionEnabled">Enable Auto-pause</label>
            <input type="checkbox" id="pauseDetectionEnabled" checked>
          </div>
          <div class="form-row">
            <label for="inactivityThreshold">Inactivity Threshold (seconds)</label>
            <input type="number" id="inactivityThreshold" min="5" max="120" step="5" value="30">
          </div>
        </div>
        
        <button class="btn" id="applySettingsBtn">Apply Settings</button>
      </div>
      
      <div class="pause-indicator" id="pauseIndicator">
        <h2 class="pulse">Recording Paused</h2>
        <p>Press resume to continue recording</p>
      </div>
      
      <div class="quality-indicator" id="qualityIndicator"></div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
      // Global state
      let psychoJS;
      let experimentWindow;
      let gazeData = [];
      let calibrationData = [];
      let isExperimentRunning = false;
      let currentTrial = 0;
      let heatmapEnabled = false;
      let recordingSession = null;
      let headCalibrationData = null;
      let coordinatePlane = null;
      let heatmapLayer = null;
      let gazeHistory = [];
      let recordingStartTime = null;
      // Long duration session variables
      let isLongDurationSession = false;
      let currentSegment = 0;
      let segmentStartTime = null;
      let isPaused = false;
      let pauseStartTime = null;
      let totalPausedTime = 0;
      let autoSaveInterval = null;
      let lastCleanupTime = null;
      let recordedSegments = [];
      let currentRecordingTime = 0;
      let lastTrackingQuality = 1.0;
      let inactivityTimer = null;
      let sessionStats = {
        totalDuration: 0,
        activeDuration: 0,
        pauseDuration: 0,
        dataPoints: 0,
        avgTrackingQuality: 1.0,
        segmentCount: 0
      };

      // Configuration
      const config = {
        fullscreen: true,
        backgroundColor: '#0f172a',
        frameRate: 60,
        calibrationPoints: 9,
        trialCount: 5,
        sampleRate: 30,
        heatmapResolution: 50,
        heatmapOpacity: 0.6,
        heatmapRadius: 50,
        heatmapColorScale: ['blue', 'green', 'yellow', 'red'],
        coordinatePlaneColor: 'rgba(255, 255, 255, 0.2)',
        coordinatePlaneSpacing: 50,
        recordingDuration: 60, // seconds
        headCalibrationSamples: 30,
        // Long duration session options
        longDurationEnabled: false,
        longDurationHours: 1, // Default 1 hour for long sessions
        segmentDuration: 10 * 60, // 10 minutes per segment
        autoSaveInterval: 5 * 60, // Auto-save every 5 minutes
        memoryManagement: {
          maxGazeHistoryPoints: 10000, // Maximum points to keep in memory
          cleanupInterval: 60, // Cleanup every 1 minute
          sampleDownsamplingFactor: 1 // No downsampling by default
        },
        pauseDetection: {
          enabled: true,
          inactivityThreshold: 30, // Seconds of inactivity before pausing
          lowQualityThreshold: 0.4 // Threshold for low quality tracking
        },
        visualization: {
          timeWindow: 60, // Show last 60 seconds in visualizations by default
          heatmapTemporalDecay: 0.9 // Decay factor for older points
        }
      };

      // UI Elements
      const ui = {
        startBtn: document.getElementById('startBtn'),
        calibrateBtn: document.getElementById('calibrateBtn'),
        abortBtn: document.getElementById('abortBtn'),
        progressBar: document.getElementById('progressBar'),
        statusText: document.getElementById('statusText'),
        notification: document.getElementById('notification'),
        exportContainer: document.getElementById('exportContainer')
      };

      // Initialize WebGazer
      async function initializeWebGazer() {
        try {
          await webgazer.setGazeListener((data, timestamp) => {
            if (data && isExperimentRunning) {
              gazeData.push({
                timestamp,
                x: data.x,
                y: data.y,
                trial: currentTrial
              });
            }
            }).begin();
      
          // Configure WebGazer
            webgazer.showVideo(false)
                     .showFaceOverlay(false)
                     .showFaceFeedbackBox(false)
                     .showPredictionPoints(false);

          return true;
        } catch (error) {
          showNotification('Failed to initialize WebGazer: ' + error.message, true);
          return false;
        }
      }

      // Initialize PsychoJS
      function initializePsychoJS() {
        psychoJS = new PsychoJS({
          debug: true
        });

        experimentWindow = new psychoJS.visual.Window({
          size: [window.innerWidth, window.innerHeight],
          fullscr: config.fullscreen,
          color: new psychoJS.Color(config.backgroundColor),
          units: 'norm'
        });

        return true;
      }

      // Calibration procedure
      async function runCalibration() {
        const points = [
          [-0.8, 0.8], [0, 0.8], [0.8, 0.8],
          [-0.8, 0], [0, 0], [0.8, 0],
          [-0.8, -0.8], [0, -0.8], [0.8, -0.8]
        ];

        calibrationData = [];
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          
          // Create calibration point
          const dot = new psychoJS.visual.Circle({
            win: experimentWindow,
            radius: 0.02,
            pos: point,
            fillColor: new psychoJS.Color('white'),
            lineWidth: 0
          });

          // Show point
          dot.draw();
          experimentWindow.flip();

          // Wait for fixation
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Collect samples
          const samples = [];
          for (let j = 0; j < 10; j++) {
            const prediction = await webgazer.getCurrentPrediction();
            if (prediction) {
              samples.push({
                x: prediction.x,
                y: prediction.y
              });
            }
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          // Calculate average
          if (samples.length > 0) {
            const avgX = samples.reduce((sum, s) => sum + s.x, 0) / samples.length;
            const avgY = samples.reduce((sum, s) => sum + s.y, 0) / samples.length;
            
            calibrationData.push({
              target: point,
              measured: [avgX, avgY]
            });
          }

          // Update progress
          updateProgress((i + 1) / points.length * 100);
        }

        return calibrationData.length === points.length;
      }

      // Initialize coordinate plane for screen
      function initCoordinatePlane() {
        coordinatePlane = document.createElement('div');
        coordinatePlane.id = 'coordinatePlane';
        coordinatePlane.style.position = 'absolute';
        coordinatePlane.style.top = '0';
        coordinatePlane.style.left = '0';
        coordinatePlane.style.width = '100%';
        coordinatePlane.style.height = '100%';
        coordinatePlane.style.pointerEvents = 'none';
        coordinatePlane.style.zIndex = '1000';
        document.body.appendChild(coordinatePlane);
        
        // Create canvas for coordinate plane
        const canvas = document.createElement('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        coordinatePlane.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        ctx.strokeStyle = config.coordinatePlaneColor;
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
        
        // Add coordinate labels
        for (let x = 0; x < canvas.width; x += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = x;
          label.style.position = 'absolute';
          label.style.left = `${x}px`;
          label.style.top = '5px';
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        for (let y = 0; y < canvas.height; y += config.coordinatePlaneSpacing * 2) {
          const label = document.createElement('div');
          label.textContent = y;
          label.style.position = 'absolute';
          label.style.left = '5px';
          label.style.top = `${y}px`;
          label.style.fontSize = '10px';
          label.style.color = 'white';
          coordinatePlane.appendChild(label);
        }
        
        return coordinatePlane;
      }
      
      // Initialize heatmap layer
      function initHeatmap() {
        if (heatmapLayer) {
          document.body.removeChild(heatmapLayer);
        }
        
        heatmapLayer = document.createElement('canvas');
        heatmapLayer.id = 'heatmapLayer';
        heatmapLayer.width = window.innerWidth;
        heatmapLayer.height = window.innerHeight;
        heatmapLayer.style.position = 'absolute';
        heatmapLayer.style.top = '0';
        heatmapLayer.style.left = '0';
        heatmapLayer.style.pointerEvents = 'none';
        heatmapLayer.style.opacity = config.heatmapOpacity;
        heatmapLayer.style.zIndex = '999';
        document.body.appendChild(heatmapLayer);
        
        return heatmapLayer;
      }
      
      // Update heatmap based on gaze history
      function updateHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure (simple 2D grid)
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Populate grid with gaze data
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
            heatGrid[gridY][gridX] += 1;
          }
        });
        
        // Find maximum value for normalization
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        // Draw heatmap
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Head position and tilt calibration
      async function calibrateHeadPosition() {
        ui.statusText.textContent = 'Head Position Calibration...';
        updateProgress(0);
        
        // Create visual guide for head position
        const headGuide = document.createElement('div');
        headGuide.style.position = 'absolute';
        headGuide.style.top = '50%';
        headGuide.style.left = '50%';
        headGuide.style.transform = 'translate(-50%, -50%)';
        headGuide.style.width = '300px';
        headGuide.style.height = '300px';
        headGuide.style.border = '2px dashed white';
        headGuide.style.borderRadius = '50%';
        headGuide.style.zIndex = '1001';
        document.body.appendChild(headGuide);
        
        // Text instructions
        const instructions = document.createElement('div');
        instructions.textContent = 'Position your head in the center and remain still';
        instructions.style.position = 'absolute';
        instructions.style.top = 'calc(50% + 170px)';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.color = 'white';
        instructions.style.fontSize = '18px';
        instructions.style.fontWeight = 'bold';
        instructions.style.zIndex = '1002';
        document.body.appendChild(instructions);
        
        // Collect head position samples
        const samples = [];
        for (let i = 0; i < config.headCalibrationSamples; i++) {
          updateProgress((i / config.headCalibrationSamples) * 100);
          
          // Get current face position from WebGazer
          const currentFace = await new Promise(resolve => {
            webgazer.getCurrentFaceFeatures().then(features => {
              resolve(features);
            });
          });
          
          if (currentFace) {
            samples.push(currentFace);
          }
          
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Calculate average head position and orientation
        if (samples.length > 0) {
          headCalibrationData = {
            timestamp: Date.now(),
            samples: samples,
            averagePosition: calculateAverageHeadPosition(samples)
          };
          
          showNotification('Head position calibrated successfully');
        } else {
          showNotification('Head calibration failed. Please try again.', true);
        }
        
        // Clean up
        document.body.removeChild(headGuide);
        document.body.removeChild(instructions);
        
        return samples.length > 0;
      }
      
      // Calculate average head position from samples
      function calculateAverageHeadPosition(samples) {
        if (!samples || samples.length === 0) return null;
        
        // This is a simplified version - in a real implementation,
        // you would extract more detailed face metrics
        const avgPosition = { x: 0, y: 0, width: 0, height: 0 };
        
        samples.forEach(sample => {
          if (sample && sample.imagex !== undefined) {
            avgPosition.x += sample.imagex;
            avgPosition.y += sample.imagey;
            avgPosition.width += sample.width;
            avgPosition.height += sample.height;
          }
        });
        
        avgPosition.x /= samples.length;
        avgPosition.y /= samples.length;
        avgPosition.width /= samples.length;
        avgPosition.height /= samples.length;
        
        return avgPosition;
      }
      
      // Start recording session
      async function startRecordingSession() {
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        recordingStartTime = Date.now();
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object
        recordingSession = {
          id: `session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        // Start recording loop
        ui.statusText.textContent = 'Recording in progress...';
        isExperimentRunning = true;
        
        const recordingLoop = async () => {
          if (!isExperimentRunning) return;
          
          const elapsedTime = (Date.now() - recordingStartTime) / 1000;
          updateProgress((elapsedTime / config.recordingDuration) * 100);
          
          // Get current gaze prediction
          const prediction = await webgazer.getCurrentPrediction();
          if (prediction) {
            // Add to history for heatmap
            gazeHistory.push({
              x: prediction.x,
              y: prediction.y,
              timestamp: Date.now() - recordingStartTime
            });
            
            // Add to recording data
            recordingSession.frames.push({
              timestamp: Date.now() - recordingStartTime,
              gazeX: prediction.x,
              gazeY: prediction.y,
              headPosition: await webgazer.getCurrentFaceFeatures()
            });
            
            // Draw current gaze point
            drawGazePoint(prediction.x, prediction.y);
            
            // Update heatmap if enabled
            if (heatmapEnabled) {
              updateHeatmap();
            }
          }
          
          // Check if recording duration has been reached
          if (elapsedTime >= config.recordingDuration) {
            stopRecordingSession();
            showNotification('Recording completed');
            ui.exportContainer.style.display = 'flex';
          } else {
            // Continue loop
            requestAnimationFrame(recordingLoop);
          }
        };
        
        // Start the recording loop
        recordingLoop();
        
        return true;
      }
      
      // Stop recording session
      function stopRecordingSession() {
        isExperimentRunning = false;
        
        if (recordingSession) {
          recordingSession.endTime = Date.now();
          recordingSession.duration = recordingSession.endTime - recordingSession.startTime;
          
          // Save recording data
          gazeData = recordingSession.frames;
          
          // Clean up
          if (coordinatePlane) {
            document.body.removeChild(coordinatePlane);
            coordinatePlane = null;
          }
          
          if (heatmapLayer) {
            document.body.removeChild(heatmapLayer);
            heatmapLayer = null;
          }
          
          ui.statusText.textContent = 'Recording stopped';
          updateProgress(100);
          
          // Stop auto-save interval if running
          if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
          }
          
          // Stop inactivity timer if running
          if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
          }
        }
      }
      
      // Draw current gaze point
      function drawGazePoint(x, y) {
        // Remove previous gaze point if exists
        const existingPoint = document.getElementById('currentGazePoint');
        if (existingPoint) {
          document.body.removeChild(existingPoint);
        }
        
        // Create new gaze point
        const gazePoint = document.createElement('div');
        gazePoint.id = 'currentGazePoint';
        gazePoint.style.position = 'absolute';
        gazePoint.style.top = `${y}px`;
        gazePoint.style.left = `${x}px`;
        gazePoint.style.width = '20px';
        gazePoint.style.height = '20px';
        gazePoint.style.borderRadius = '50%';
        gazePoint.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
        gazePoint.style.transform = 'translate(-50%, -50%)';
        gazePoint.style.zIndex = '1003';
        gazePoint.style.pointerEvents = 'none';
        document.body.appendChild(gazePoint);
        
        // Add ripple effect
        const ripple = document.createElement('div');
        ripple.style.position = 'absolute';
        ripple.style.top = '50%';
        ripple.style.left = '50%';
        ripple.style.width = '100%';
        ripple.style.height = '100%';
        ripple.style.borderRadius = '50%';
        ripple.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        ripple.style.transform = 'translate(-50%, -50%) scale(1)';
        ripple.style.transition = 'all 0.5s ease-out';
        gazePoint.appendChild(ripple);
        
        setTimeout(() => {
          ripple.style.transform = 'translate(-50%, -50%) scale(2)';
          ripple.style.opacity = '0';
        }, 10);
      }
      
      // Toggle heatmap visibility
      function toggleHeatmap() {
        heatmapEnabled = !heatmapEnabled;
        
        if (heatmapEnabled) {
          if (!heatmapLayer) {
            initHeatmap();
          }
          updateHeatmap();
          showNotification('Heatmap enabled');
        } else {
          if (heatmapLayer) {
            const ctx = heatmapLayer.getContext('2d');
            ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
          }
          showNotification('Heatmap disabled');
        }
      }
      
      // Export recording data
      function exportRecordingData() {
        if (!recordingSession || recordingSession.frames.length === 0) {
          showNotification('No recording data available', true);
          return;
        }
        
        // Prepare CSV data
        const csvContent = "data:text/csv;charset=utf-8," + 
          "timestamp,gazeX,gazeY,headX,headY,headWidth,headHeight\n" +
          recordingSession.frames.map(frame => {
            const head = frame.headPosition || {};
            return `${frame.timestamp},${frame.gazeX},${frame.gazeY},` +
                   `${head.imagex || ''},${head.imagey || ''},` +
                   `${head.width || ''},${head.height || ''}`;
          }).join("\n");
        
        // Create download link
        const csvLink = document.createElement('a');
        csvLink.href = encodeURI(csvContent);
        csvLink.download = `gaze_recording_${recordingSession.id}.csv`;
        csvLink.click();
        
        // Prepare JSON data
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify({
            sessionInfo: {
              id: recordingSession.id,
              startTime: recordingSession.startTime,
              endTime: recordingSession.endTime,
              duration: recordingSession.duration,
              screenDimensions: recordingSession.screenDimensions
            },
            headCalibration: recordingSession.headCalibration,
            frames: recordingSession.frames
          }));
        
        // Create download link
        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = `gaze_recording_${recordingSession.id}.json`;
        jsonLink.click();
        
        showNotification('Recording data exported');
      }

      // Run a single trial
      async function runTrial(trialNumber) {
        currentTrial = trialNumber;
        
        // Show fixation cross
        const fixation = new psychoJS.visual.TextStim({
          win: experimentWindow,
          text: '+',
          height: 0.1,
          color: new psychoJS.Color('white')
        });

        fixation.draw();
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Show stimulus
        const stimulus = new psychoJS.visual.TextStim({
          win: experimentWindow,
          text: `Trial ${trialNumber}`,
          height: 0.1,
          color: new psychoJS.Color('white')
        });

        stimulus.draw();
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Inter-trial interval
        experimentWindow.flip();
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      // Export data
      function exportData() {
        // CSV Export
        const csvContent = "data:text/csv;charset=utf-8," + 
          "timestamp,x,y,trial\n" +
          gazeData.map(row => 
            `${row.timestamp},${row.x},${row.y},${row.trial}`
          ).join("\n");

        const csvLink = document.createElement('a');
        csvLink.href = encodeURI(csvContent);
        csvLink.download = 'gaze_data.csv';
        csvLink.click();

        // JSON Export
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(gazeData));

        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = 'gaze_data.json';
        jsonLink.click();
      }

      // UI Updates
      function updateProgress(percent) {
        ui.progressBar.style.width = `${percent}%`;
      }

      function showNotification(message, isError = false) {
        ui.notification.textContent = message;
        ui.notification.classList.toggle('error', isError);
        ui.notification.classList.add('show');
        setTimeout(() => ui.notification.classList.remove('show'), 3000);
      }

      function resetUI() {
        ui.calibrateBtn.disabled = true;
        ui.abortBtn.disabled = true;
        ui.progressBar.style.width = '0%';
        ui.statusText.textContent = 'Experiment ready';
        ui.exportContainer.style.display = 'none';
      }

      // MODIFY EXISTING UI ELEMENTS AND ADD NEW ONES
      document.addEventListener('DOMContentLoaded', () => {
        // Add new buttons for the second pipeline
        const controls = document.querySelector('.controls');
        
        // Add heatmap toggle button
        const heatmapBtn = document.createElement('button');
        heatmapBtn.id = 'heatmapBtn';
        heatmapBtn.className = 'btn';
        heatmapBtn.type = 'button';
        heatmapBtn.textContent = 'Toggle Heatmap';
        heatmapBtn.disabled = true;
        controls.appendChild(heatmapBtn);
        
        // Add head calibration button
        const headCalibBtn = document.createElement('button');
        headCalibBtn.id = 'headCalibBtn';
        headCalibBtn.className = 'btn';
        headCalibBtn.type = 'button';
        headCalibBtn.textContent = 'Calibrate Head Position';
        headCalibBtn.disabled = true;
        controls.appendChild(headCalibBtn);
        
        // Add recording button
        const recordBtn = document.createElement('button');
        recordBtn.id = 'recordBtn';
        recordBtn.className = 'btn';
        recordBtn.type = 'button';
        recordBtn.textContent = 'Start Recording';
        recordBtn.disabled = true;
        controls.appendChild(recordBtn);
        
        // Update UI object with new elements
        ui.heatmapBtn = heatmapBtn;
        ui.headCalibBtn = headCalibBtn;
        ui.recordBtn = recordBtn;
        ui.longDurationControls = document.getElementById('longDurationControls');
        ui.startLongSessionBtn = document.getElementById('startLongSessionBtn');
        ui.pauseResumeBtn = document.getElementById('pauseResumeBtn');
        ui.settingsBtn = document.getElementById('settingsBtn');
        ui.saveSegmentBtn = document.getElementById('saveSegmentBtn');
        ui.sessionStats = document.getElementById('sessionStats');
        ui.settingsPanel = document.getElementById('settingsPanel');
        ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
        ui.applySettingsBtn = document.getElementById('applySettingsBtn');
        ui.pauseIndicator = document.getElementById('pauseIndicator');
        ui.qualityIndicator = document.getElementById('qualityIndicator');
        ui.exportAllSegments = document.getElementById('exportAllSegments');
        
        // Add event listeners for new buttons
        ui.heatmapBtn.addEventListener('click', toggleHeatmap);
        
        ui.headCalibBtn.addEventListener('click', async () => {
          try {
            const headCalibrationSuccess = await calibrateHeadPosition();
            if (headCalibrationSuccess) {
              ui.recordBtn.disabled = false;
              ui.startLongSessionBtn.disabled = false;
              ui.longDurationControls.style.display = 'flex';
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.recordBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning) {
              stopRecordingSession();
              ui.recordBtn.textContent = 'Start Recording';
            } else {
              const recordingStarted = await startRecordingSession();
              if (recordingStarted) {
                ui.recordBtn.textContent = 'Stop Recording';
                ui.heatmapBtn.disabled = false;
              }
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        // Long duration session event listeners
        ui.startLongSessionBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning) {
              await finishLongDurationSession();
              ui.startLongSessionBtn.textContent = 'Start Long Session';
            } else {
              const sessionStarted = await startLongDurationSession();
              if (sessionStarted) {
                ui.startLongSessionBtn.textContent = 'End Long Session';
                ui.heatmapBtn.disabled = false;
                ui.pauseResumeBtn.disabled = false;
                ui.saveSegmentBtn.disabled = false;
              }
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.pauseResumeBtn.addEventListener('click', () => {
          togglePauseRecording();
        });
        
        ui.settingsBtn.addEventListener('click', () => {
          ui.settingsPanel.style.display = 'block';
          
          // Set current values in the form
          document.getElementById('sessionDurationHours').value = config.longDurationHours;
          document.getElementById('segmentDuration').value = config.segmentDuration / 60;
          document.getElementById('autoSaveInterval').value = config.autoSaveInterval / 60;
          document.getElementById('maxGazePoints').value = config.memoryManagement.maxGazeHistoryPoints;
          document.getElementById('downsamplingFactor').value = config.memoryManagement.sampleDownsamplingFactor;
          document.getElementById('pauseDetectionEnabled').checked = config.pauseDetection.enabled;
          document.getElementById('inactivityThreshold').value = config.pauseDetection.inactivityThreshold;
        });
        
        ui.closeSettingsBtn.addEventListener('click', () => {
          ui.settingsPanel.style.display = 'none';
        });
        
        ui.applySettingsBtn.addEventListener('click', () => {
          applySettings();
        });
        
        ui.saveSegmentBtn.addEventListener('click', async () => {
          try {
            if (isExperimentRunning && isLongDurationSession) {
              await saveCurrentSegment();
              startNewSegment();
            }
          } catch (error) {
            showNotification(error.message, true);
          }
        });
        
        ui.exportAllSegments.addEventListener('click', () => {
          exportAllSegments();
        });
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.key === 'h' || e.key === 'H') {
            if (!ui.heatmapBtn.disabled) {
              toggleHeatmap();
            }
          } else if (e.key === 'Escape') {
            if (isExperimentRunning) {
              if (isLongDurationSession) {
                togglePauseRecording();
                showNotification('Recording paused with ESC key');
              } else {
                stopRecordingSession();
                ui.recordBtn.textContent = 'Start Recording';
                showNotification('Recording stopped with ESC key');
              }
            }
          } else if (e.key === 'p' || e.key === 'P') {
            if (isLongDurationSession && isExperimentRunning) {
              togglePauseRecording();
            }
          } else if (e.key === 's' || e.key === 'S') {
            if (isLongDurationSession && isExperimentRunning && !isPaused) {
              saveCurrentSegment();
              startNewSegment();
              showNotification('Segment saved with S key');
            }
          }
        });
      });

      // Event Handlers
      ui.startBtn.addEventListener('click', async () => {
        try {
          const webgazerInitialized = await initializeWebGazer();
          const psychojsInitialized = initializePsychoJS();

          if (webgazerInitialized && psychojsInitialized) {
            ui.calibrateBtn.disabled = false;
            ui.abortBtn.disabled = false;
            ui.headCalibBtn.disabled = false;
            showNotification('Experiment initialized successfully');
          }
        } catch (error) {
          showNotification(error.message, true);
        }
      });

      ui.calibrateBtn.addEventListener('click', async () => {
        try {
          ui.statusText.textContent = 'Calibrating...';
          const calibrationSuccess = await runCalibration();
          
          if (calibrationSuccess) {
            showNotification('Calibration completed successfully');
            isExperimentRunning = true;
            
            // Run trials
            for (let trial = 1; trial <= config.trialCount; trial++) {
              if (!isExperimentRunning) break;
          await runTrial(trial);
              updateProgress(trial / config.trialCount * 100);
            }

            // Show export options
            ui.exportContainer.style.display = 'flex';
          }
        } catch (error) {
          showNotification(error.message, true);
        }
      });

      ui.abortBtn.addEventListener('click', () => {
        if (isLongDurationSession) {
          finishLongDurationSession();
        } else {
          isExperimentRunning = false;
          webgazer.end();
          showNotification('Experiment aborted');
          resetUI();
        }
      });

      ui.exportCSV.addEventListener('click', () => exportData());
      ui.exportJSON.addEventListener('click', () => exportData());

      // Handle window unload
      window.addEventListener('beforeunload', (e) => {
        if (isExperimentRunning && isLongDurationSession) {
          // Try to auto-save if closing during long session
          performAutoSave();
          
          // Show confirmation to prevent accidental closing
          e.preventDefault();
          e.returnValue = 'You have an active recording session. Are you sure you want to leave?';
          return e.returnValue;
        }
        
        if (webgazer) webgazer.end();
        if (psychoJS) psychoJS.quit();
        if (recordingSession) {
          stopRecordingSession();
        }
      });

      // Start a long duration recording session
      async function startLongDurationSession() {
        // Reset stats
        sessionStats = {
          totalDuration: 0,
          activeDuration: 0,
          pauseDuration: 0,
          dataPoints: 0,
          avgTrackingQuality: 1.0,
          segmentCount: 0
        };
        
        // Reset session state
        isLongDurationSession = true;
        currentSegment = 0;
        recordedSegments = [];
        totalPausedTime = 0;
        isPaused = false;
        
        // Update UI
        ui.sessionStats.style.display = 'block';
        ui.statusText.textContent = 'Starting long duration session...';
        
        // Initialize recording components similar to regular recording
        if (recordingSession) {
          stopRecordingSession();
        }
        
        // Initialize recording components
        gazeHistory = [];
        recordingStartTime = Date.now();
        segmentStartTime = recordingStartTime;
        lastCleanupTime = recordingStartTime;
        
        // Initialize session duration in milliseconds
        const totalSessionDuration = config.longDurationHours * 60 * 60 * 1000;
        
        // Initialize coordinate plane and heatmap
        initCoordinatePlane();
        initHeatmap();
        
        // Create recording session object
        recordingSession = {
          id: `long_session_${Date.now()}`,
          startTime: recordingStartTime,
          frames: [],
          headCalibration: headCalibrationData,
          totalSessionDuration: totalSessionDuration,
          segmentDuration: config.segmentDuration * 1000,
          segments: [],
          currentSegment: {
            id: `segment_0_${Date.now()}`,
            startTime: recordingStartTime,
            frames: []
          },
          screenDimensions: {
            width: window.innerWidth,
            height: window.innerHeight
          }
        };
        
        // Update UI elements
        updateSegmentIndicator();
        
        // Start recording loop
        ui.statusText.textContent = 'Long duration recording in progress...';
        isExperimentRunning = true;
        
        // Start auto-save interval
        startAutoSave();
        
        // Start recording loop
        longDurationRecordingLoop();
        
        // Update UI buttons
        ui.pauseResumeBtn.disabled = false;
        ui.saveSegmentBtn.disabled = false;
        
        return true;
      }
      
      // Long duration recording loop
      async function longDurationRecordingLoop() {
        if (!isExperimentRunning) return;
        if (isPaused) {
          // If paused, just update the pause time and continue the loop
          updatePauseTime();
          requestAnimationFrame(longDurationRecordingLoop);
          return;
        }
        
        const now = Date.now();
        const totalElapsedTime = now - recordingStartTime - totalPausedTime;
        const segmentElapsedTime = now - segmentStartTime - totalPausedTime;
        
        // Update session statistics
        currentRecordingTime = totalElapsedTime;
        sessionStats.totalDuration = totalElapsedTime;
        sessionStats.activeDuration = totalElapsedTime - sessionStats.pauseDuration;
        
        // Update progress based on total session duration
        const totalProgress = (totalElapsedTime / (config.longDurationHours * 60 * 60 * 1000)) * 100;
        updateProgress(Math.min(totalProgress, 100));
        
        // Update timeline visualization
        updateTimelineVisualization(totalElapsedTime);
        
        // Check if we need to start a new segment
        const segmentDurationMs = config.segmentDuration * 1000;
        if (segmentElapsedTime >= segmentDurationMs) {
          await saveCurrentSegment();
          startNewSegment();
        }
        
        // Get current gaze prediction
        const prediction = await webgazer.getCurrentPrediction();
        if (prediction) {
          // Get face features for tracking quality calculation
          const faceFeatures = await webgazer.getCurrentFaceFeatures();
          const trackingQuality = calculateTrackingQuality(faceFeatures);
          
          // Reset inactivity timer when we get a good prediction
          resetInactivityTimer();
          
          // Add to history for heatmap with temporal information
          gazeHistory.push({
            x: prediction.x,
            y: prediction.y,
            timestamp: now,
            quality: trackingQuality
          });
          
          // Add to recording data
          const frameData = {
            timestamp: now - recordingStartTime - totalPausedTime,
            gazeX: prediction.x,
            gazeY: prediction.y,
            trackingQuality: trackingQuality,
            headPosition: faceFeatures
          };
          
          recordingSession.frames.push(frameData);
          recordingSession.currentSegment.frames.push(frameData);
          
          // Update stats
          sessionStats.dataPoints++;
          updateSessionStatsUI();
          
          // Draw current gaze point
          drawGazePoint(prediction.x, prediction.y);
          
          // Update heatmap if enabled
          if (heatmapEnabled) {
            updateTemporalHeatmap();
          }
          
          // Update quality indicator
          updateQualityIndicator(trackingQuality);
        }
        
        // Check if we need to perform memory management
        const timeSinceLastCleanup = now - lastCleanupTime;
        if (timeSinceLastCleanup > config.memoryManagement.cleanupInterval * 1000) {
          performMemoryManagement();
          lastCleanupTime = now;
        }
        
        // Check if total session duration has been reached
        const totalSessionDurationMs = config.longDurationHours * 60 * 60 * 1000;
        if (totalElapsedTime >= totalSessionDurationMs) {
          await finishLongDurationSession();
        } else {
          // Continue loop
          requestAnimationFrame(longDurationRecordingLoop);
        }
      }
      
      // Start a new segment in the recording
      function startNewSegment() {
        currentSegment++;
        segmentStartTime = Date.now();
        
        // Create new segment
        recordingSession.currentSegment = {
          id: `segment_${currentSegment}_${Date.now()}`,
          startTime: segmentStartTime,
          frames: []
        };
        
        // Update stats
        sessionStats.segmentCount++;
        
        // Update UI
        updateSegmentIndicator();
        showNotification(`Started segment ${currentSegment + 1}`);
      }
      
      // Save the current segment
      async function saveCurrentSegment() {
        if (!recordingSession || !recordingSession.currentSegment) return;
        
        const segment = recordingSession.currentSegment;
        segment.endTime = Date.now();
        segment.duration = segment.endTime - segment.startTime;
        
        // Add segment to segments array
        recordingSession.segments.push({...segment});
        recordedSegments.push({...segment});
        
        // Notify user
        showNotification(`Saved segment ${currentSegment + 1}`);
        
        // Optionally export the segment
        await exportSegment(segment);
        
        return segment;
      }
      
      // Auto-save functionality
      function startAutoSave() {
        if (autoSaveInterval) {
          clearInterval(autoSaveInterval);
        }
        
        const autoSaveIntervalMs = config.autoSaveInterval * 1000;
        autoSaveInterval = setInterval(async () => {
          if (isExperimentRunning && !isPaused) {
            await performAutoSave();
          }
        }, autoSaveIntervalMs);
      }
      
      // Perform auto-save
      async function performAutoSave() {
        // Create a snapshot of the current recording data
        const snapshot = {
          timestamp: Date.now(),
          sessionData: {...recordingSession},
          sessionStats: {...sessionStats}
        };
        
        // Save to localStorage for recovery purposes
        try {
          localStorage.setItem('eyeTracking_autoSave', JSON.stringify(snapshot));
          showNotification('Session auto-saved');
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }
      
      // Pause/resume the recording
      function togglePauseRecording() {
        if (!isExperimentRunning || !isLongDurationSession) return;
        
        if (isPaused) {
          // Resume recording
          const pauseDuration = Date.now() - pauseStartTime;
          totalPausedTime += pauseDuration;
          sessionStats.pauseDuration += pauseDuration;
          
          isPaused = false;
          ui.pauseResumeBtn.textContent = 'Pause';
          ui.pauseIndicator.style.display = 'none';
          showNotification('Recording resumed');
        } else {
          // Pause recording
          isPaused = true;
          pauseStartTime = Date.now();
          ui.pauseResumeBtn.textContent = 'Resume';
          ui.pauseIndicator.style.display = 'block';
          showNotification('Recording paused');
        }
      }
      
      // Complete a long duration session
      async function finishLongDurationSession() {
        // Save the final segment
        await saveCurrentSegment();
        
        // Stop the recording
        stopRecordingSession();
        
        // Update UI
        ui.statusText.textContent = 'Long duration session completed';
        ui.exportContainer.style.display = 'flex';
        
        // Show completion notification
        showNotification('Long duration session completed successfully');
        
        // Reset flags
        isLongDurationSession = false;
        
        // Generate session summary
        generateSessionSummary();
      }
      
      // Memory management for long recordings
      function performMemoryManagement() {
        // Downsampling factor from config
        const factor = config.memoryManagement.sampleDownsamplingFactor;
        
        // Limit frames in memory if needed
        if (recordingSession.frames.length > config.memoryManagement.maxGazeHistoryPoints) {
          // Only keep the most recent points
          const startIndex = recordingSession.frames.length - config.memoryManagement.maxGazeHistoryPoints;
          recordingSession.frames = recordingSession.frames.slice(startIndex);
        }
        
        // Limit gaze history for visualization
        if (gazeHistory.length > config.memoryManagement.maxGazeHistoryPoints) {
          // Only keep recent points
          const startIndex = gazeHistory.length - config.memoryManagement.maxGazeHistoryPoints;
          gazeHistory = gazeHistory.slice(startIndex);
        }
        
        // Apply downsampling if factor > 1
        if (factor > 1 && recordingSession.frames.length > 1000) {
          // Keep every Nth frame
          recordingSession.frames = recordingSession.frames.filter((_, index) => index % factor === 0);
          showNotification(`Memory optimized: Downsampled by ${factor}x`);
        }
      }
      
      // Reset inactivity timer
      function resetInactivityTimer() {
        if (inactivityTimer) {
          clearTimeout(inactivityTimer);
        }
        
        // Only set up inactivity detection if enabled
        if (config.pauseDetection.enabled) {
          inactivityTimer = setTimeout(() => {
            // Auto-pause if we're in a long duration session and not already paused
            if (isLongDurationSession && isExperimentRunning && !isPaused) {
              showNotification('Auto-paused due to inactivity', true);
              togglePauseRecording();
            }
          }, config.pauseDetection.inactivityThreshold * 1000);
        }
      }
      
      // Calculate tracking quality from face features
      function calculateTrackingQuality(faceFeatures) {
        // Simple quality metric (customize based on your needs)
        if (!faceFeatures) return 0;
        
        // Calculate based on face detection confidence or other metrics
        // This is a simplified example
        let quality = 1.0;
        
        // Adjust quality based on face position, size, etc.
        if (faceFeatures.width < 100 || faceFeatures.height < 100) {
          quality *= 0.8; // Face too small
        }
        
        lastTrackingQuality = quality;
        return quality;
      }
      
      // Update quality indicator
      function updateQualityIndicator(quality) {
        const indicator = document.getElementById('qualityIndicator');
        
        if (quality > 0.7) {
          indicator.className = 'quality-indicator';
        } else if (quality > 0.4) {
          indicator.className = 'quality-indicator medium';
        } else {
          indicator.className = 'quality-indicator low';
        }
      }
      
      // Export a single segment
      async function exportSegment(segment) {
        if (!segment || segment.frames.length === 0) return;
        
        // Prepare segment data for export
        const segmentData = {
          id: segment.id,
          startTime: segment.startTime,
          endTime: segment.endTime || Date.now(),
          duration: segment.duration || (Date.now() - segment.startTime),
          framesCount: segment.frames.length,
          frames: segment.frames
        };
        
        // Export JSON format (can add CSV format as needed)
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(segmentData));
        
        // Create download link - but don't auto-download to avoid browser blocking
        // Just store for later batch download
        segment.exportData = jsonContent;
        
        return segmentData;
      }
      
      // Export all segments
      function exportAllSegments() {
        if (!recordedSegments || recordedSegments.length === 0) {
          showNotification('No segments available to export', true);
          return;
        }
        
        // Create a zip-like format with all segments
        const allSegmentsData = {
          sessionId: recordingSession?.id || `session_${Date.now()}`,
          startTime: recordingSession?.startTime || recordedSegments[0].startTime,
          endTime: Date.now(),
          segmentsCount: recordedSegments.length,
          totalDataPoints: sessionStats.dataPoints,
          segments: recordedSegments.map(segment => ({
            id: segment.id,
            startTime: segment.startTime,
            endTime: segment.endTime || Date.now(),
            duration: segment.duration || (Date.now() - segment.startTime),
            framesCount: segment.frames.length
          })),
          stats: sessionStats
        };
        
        // Create JSON download
        const jsonContent = "data:text/json;charset=utf-8," + 
          encodeURIComponent(JSON.stringify(allSegmentsData));
        
        // Create download link
        const jsonLink = document.createElement('a');
        jsonLink.href = jsonContent;
        jsonLink.download = `eye_tracking_session_${Date.now()}.json`;
        jsonLink.click();
        
        showNotification(`Exported ${recordedSegments.length} segments`);
      }
      
      // Update segment indicator in UI
      function updateSegmentIndicator() {
        const container = document.getElementById('segmentIndicator');
        container.innerHTML = '';
        
        // Calculate how many segments we expect in total
        const totalDurationMs = config.longDurationHours * 60 * 60 * 1000;
        const segmentDurationMs = config.segmentDuration * 1000;
        const expectedSegments = Math.ceil(totalDurationMs / segmentDurationMs);
        
        // Create segment indicators
        for (let i = 0; i < expectedSegments; i++) {
          const dot = document.createElement('div');
          dot.className = 'segment-dot';
          
          if (i < currentSegment) {
            dot.classList.add('completed');
          } else if (i === currentSegment) {
            dot.classList.add('active');
          }
          
          container.appendChild(dot);
        }
      }
      
      // Format time for display (HH:MM:SS)
      function formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        
        return [
          hours.toString().padStart(2, '0'),
          minutes.toString().padStart(2, '0'),
          seconds.toString().padStart(2, '0')
        ].join(':');
      }
      
      // Update session statistics UI
      function updateSessionStatsUI() {
        document.getElementById('totalTimeValue').textContent = formatTime(sessionStats.totalDuration);
        document.getElementById('activeTimeValue').textContent = formatTime(sessionStats.activeDuration);
        document.getElementById('pauseTimeValue').textContent = formatTime(sessionStats.pauseDuration);
        document.getElementById('dataPointsValue').textContent = sessionStats.dataPoints.toLocaleString();
        document.getElementById('trackingQualityValue').textContent = `${Math.round(lastTrackingQuality * 100)}%`;
        document.getElementById('segmentCountValue').textContent = sessionStats.segmentCount + 1; // +1 for current segment
      }
      
      // Update pause time counter
      function updatePauseTime() {
        if (isPaused) {
          const currentPauseDuration = Date.now() - pauseStartTime;
          document.getElementById('pauseTimeValue').textContent = formatTime(sessionStats.pauseDuration + currentPauseDuration);
        }
      }
      
      // Update timeline visualization
      function updateTimelineVisualization(currentTimeMs) {
        const timeline = document.getElementById('sessionTimeline');
        const cursor = document.getElementById('timelineCursor');
        
        // Clear existing segments
        const existingSegments = timeline.querySelectorAll('.timeline-segment');
        existingSegments.forEach(el => el.remove());
        
        // Add completed segments
        const totalDurationMs = config.longDurationHours * 60 * 60 * 1000;
        recordedSegments.forEach((segment, index) => {
          const segmentEl = document.createElement('div');
          segmentEl.className = 'timeline-segment';
          
          // Position the segment on the timeline
          const startPercent = (segment.startTime - recordingStartTime - totalPausedTime) / totalDurationMs * 100;
          const endPercent = ((segment.endTime || Date.now()) - recordingStartTime - totalPausedTime) / totalDurationMs * 100;
          const width = endPercent - startPercent;
          
          segmentEl.style.left = `${startPercent}%`;
          segmentEl.style.width = `${width}%`;
          
          timeline.appendChild(segmentEl);
        });
        
        // Position the current time cursor
        const cursorPosition = (currentTimeMs / totalDurationMs) * 100;
        cursor.style.left = `${cursorPosition}%`;
      }
      
      // Update heatmap with temporal weighting
      function updateTemporalHeatmap() {
        if (!heatmapLayer || !heatmapEnabled || gazeHistory.length === 0) return;
        
        const ctx = heatmapLayer.getContext('2d');
        ctx.clearRect(0, 0, heatmapLayer.width, heatmapLayer.height);
        
        // Create heatmap data structure
        const gridSize = config.heatmapResolution;
        const cellWidth = heatmapLayer.width / gridSize;
        const cellHeight = heatmapLayer.height / gridSize;
        const heatGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        // Get current time for temporal weighting
        const now = Date.now();
        const timeWindow = config.visualization.timeWindow * 1000; // convert to ms
        
        // Populate grid with gaze data with temporal weighting
        gazeHistory.forEach(point => {
          if (!point || point.x === undefined || point.y === undefined) return;
          
          const gridX = Math.floor(point.x / cellWidth);
          const gridY = Math.floor(point.y / cellHeight);
          
          // Only include points in the visualization time window
          if (now - point.timestamp <= timeWindow) {
            if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
              // Apply temporal weighting - more recent points have higher weight
              const age = (now - point.timestamp) / timeWindow;
              const weight = Math.pow(config.visualization.heatmapTemporalDecay, age);
              heatGrid[gridY][gridX] += weight;
            }
          }
        });
        
        // Draw heatmap (similar to existing implementation but with temporal weights)
        let maxVal = 1;
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            maxVal = Math.max(maxVal, heatGrid[y][x]);
          }
        }
        
        for (let y = 0; y < gridSize; y++) {
          for (let x = 0; x < gridSize; x++) {
            const intensity = heatGrid[y][x] / maxVal;
            if (intensity > 0) {
              const colorIndex = Math.min(
                Math.floor(intensity * config.heatmapColorScale.length),
                config.heatmapColorScale.length - 1
              );
              
              ctx.fillStyle = config.heatmapColorScale[colorIndex];
              ctx.beginPath();
              ctx.arc(
                x * cellWidth + cellWidth / 2,
                y * cellHeight + cellHeight / 2,
                config.heatmapRadius * Math.sqrt(intensity),
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        }
      }
      
      // Apply settings from the settings panel
      function applySettings() {
        // Get values from form
        const hours = parseFloat(document.getElementById('sessionDurationHours').value);
        const segmentDurationMinutes = parseInt(document.getElementById('segmentDuration').value);
        const autoSaveIntervalMinutes = parseInt(document.getElementById('autoSaveInterval').value);
        const maxGazePoints = parseInt(document.getElementById('maxGazePoints').value);
        const downsamplingFactor = parseInt(document.getElementById('downsamplingFactor').value);
        const pauseDetectionEnabled = document.getElementById('pauseDetectionEnabled').checked;
        const inactivityThreshold = parseInt(document.getElementById('inactivityThreshold').value);
        
        // Update config
        config.longDurationHours = hours;
        config.segmentDuration = segmentDurationMinutes * 60; // convert to seconds
        config.autoSaveInterval = autoSaveIntervalMinutes * 60; // convert to seconds
        config.memoryManagement.maxGazeHistoryPoints = maxGazePoints;
        config.memoryManagement.sampleDownsamplingFactor = downsamplingFactor;
        config.pauseDetection.enabled = pauseDetectionEnabled;
        config.pauseDetection.inactivityThreshold = inactivityThreshold;
        
        // Update auto-save interval if running
        if (autoSaveInterval) {
          clearInterval(autoSaveInterval);
          startAutoSave();
        }
        
        // Hide settings panel
        document.getElementById('settingsPanel').style.display = 'none';
        
        showNotification('Settings applied');
      }
      
      // Generate session summary at the end
      function generateSessionSummary() {
        // Create a printable summary
        const summary = {
          sessionId: recordingSession?.id,
          duration: {
            total: formatTime(sessionStats.totalDuration),
            active: formatTime(sessionStats.activeDuration),
            paused: formatTime(sessionStats.pauseDuration)
          },
          segments: sessionStats.segmentCount,
          dataPoints: sessionStats.dataPoints,
          avgQuality: `${Math.round(sessionStats.avgTrackingQuality * 100)}%`,
          timestamp: new Date().toISOString()
        };
        
        console.log('Session Summary:', summary);
        return summary;
      }
    </script>
  </body>
</html>